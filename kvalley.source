; -------------------- 900878119 contadores - 900850840 / endesa distribucion.
; -------------------- CODIGO OPERARIO 41027, MANSEL.
; King's Valley Remake
; M.A software 2021
; --------------------

.Definitions

; Configurar en el compilador
;
; Shapes = 420
; Sounds = 10

; Valor de la posicion vertical 0, de los Slices
;
#TopSlice = 44; 39

; Colores
;
#Color_black = 0
#Color_red = 6
#Color_white = 15

; Valores de ciertos tiles de interes para dibujarlos
;
#Tile_dagger=176
#Tile_picker=177
#Tile_break=178
#Tile_giratory_toright=181
#Tile_giratory_toleft=199
#Tile_push_up=201
#Tile_push_down=203
#Tile_push_down_off=205
#Tile_door=217
#Tile_doorleft=218
#Tile_doorright=219

#BaseTiles = 0
#BaseSprites = 220
#BaseTopShapes = 397
#BufferA = 0
#BufferB = 1
#BufferC = 2
#BufferD = 3
#BufferDoor1 = 4
#BufferDoor2 = 5
#BBuff0 = 0
#BBuff1 = 1
#SafeMargin=20
#GamePalette = 3

; -------
; Sonidos
; -------
;
#FxSoundMask=8

#Snd_dead=0
#Snd_picking=1
#Snd_door=2
#Snd_rotadoor=3
#Snd_falling=4
#Snd_takejewel=5
#Snd_takepicker=6
#Snd_throwdagger=7
#Snd_jump=8
#Snd_mummyappear=9
#Snd_mummydead=10

#Med_music=0        ; Numero de MED
#Med_intro=0        ; Pattern de la musica INTRO
#Med_gameover=4     ; Pattern de la musica de GameOver
#Med_pyramidmap=5   ; Pattern de la musica del mapa
#Med_endgame=6      ; Pattern de la musica del Final
#Med_maintitle=17   ; Pattern de la musica de MainTitle
#Med_music1=1       ; Pattern de la musica 1
#Med_music2=13      ; Pattern de la musica 2
#Med_music3=18      ; Pattern de la musica 3

; ---------------------------------------------
; Constantes para identificar tipo de elementos
; ---------------------------------------------
;
#It_none = 0        ; Nada
#It_brick = 76      ; Asc("L") Ladrillo
#It_giratory = 71   ; Asc("G") Puerta Giratoria
#It_rgiratory = 62  ; Asc(">") Puerta Giratoria a Derecha
#It_lgiratory = 60  ; Asc("<") Puerta Giratoria a Izquierda
#It_dagger = 68     ; Asc("D") Daga
#It_picker = 80     ; Asc("P") Pico
#It_jewel = 74      ; Asc("J") Joya
#It_door = 84       ; Asc("T") Puerta Entrada/Salida
#It_wall = 85       ; Asc("U") Muro que aparece y crece
#It_mummy = 77      ; Asc("M") Posicion de Momia
#It_stairs = 69     ; Asc("E") Escalera
#It_stair_ur = 48   ; Asc("0") Escalera Sube-Derecha
#It_stair_dl = 49   ; Asc("1") Escalera Baja-Izquierda
#It_stair_ul = 50   ; Asc("2") Escalera Sube-Izquierda
#It_stair_dr = 51   ; Asc("3") Escalera Baja-Derecha
#It_push_in = 73    ; Asc("I") Interruptor puerta entrada
#It_push_out = 79   ; Asc("O") Interruptor puerta de salida

; -------------------------------
; Estructura para pasar los parametros
; a la creacion de un gradiente de color
; que se usara para crear un rainbow
;
; cindex = Color sobre el que se crea el rainbow
; y0 = Primera Coordenada Vertical donde comienza en Rainbow
; r0,g0,b0 = Tonalidad de la linea inicial
; y1 = Linea donde termina el Rainbow
; r1,g1,b1 = Tonalidad de la linea final
;
NEWTYPE .TRainbow
  cindex.b
  y0.w:r0.b:g0.b:b0.b
  y1.w:r1.b:g1.b:b1.b
End NEWTYPE

; Estructura para gestionar temporizadores
;
NEWTYPE .TTimer
  toptimer.l
  sexages.w
End NEWTYPE

; ---------------------------------
; Tipo TItem de objetos de pantalla
; ---------------------------------
;
NEWTYPE .TItem
  otype.b
  x.b : y.b
  p0.b : p1.b
  buffc.b      ; Contador de buffer, usado para restaurar tiles
  work.b       ; Valor para establecer en la capa work
  enabled.b    ; Para cuando se requiera saber si el item esta activo o no
End NEWTYPE

; ---------------------
; Control del MedPlayer
; ---------------------
;
NEWTYPE .TMedPlayer
  music.w
  mask.w
  playing.b
End NEWTYPE

; -------------------------------
; Tipo TWall muros que se cierran
; -------------------------------
;
NEWTYPE .TWall
  x.b : y.b
  y1.b : x1.b
  state.b      ; Estado del muro
  counter1.b   ; Contador 1
  tileid.b       ; Valor del tile de ladrillo a pintar
  enabled.b    ; Para cuando se requiera saber si el item esta activo o no
  timer.TTimer
End NEWTYPE

#stWall_waiting=0
#stWall_closing=1
#stWall_closed=2

; -------------------------------------------
; Tipo TBright, para gestionar brillo de joya
; -------------------------------------------
;
NEWTYPE .TBright
  pjewel.l
  timer.TTimer
End NEWTYPE

; ------------------------------------------------------
; Tipo TPyramid, almacena la informacion de una piramide
; ------------------------------------------------------
;
NEWTYPE .TPyramid
  level.b
  w.b : h.b
  jewels.b
  back.l
  front.l
  work.l
End NEWTYPE

; ------------------------------------
; Estructura para el control de teclas
; ------------------------------------
;
NEWTYPE .KeyState
  left.b
  right.b
  up.b
  down.b
  fire.b
  esc.b
  keydown.b
End NEWTYPE

; -------------------------
; Estructura para animacion
; -------------------------
;
NEWTYPE .TAnimation
  frame.w
  framebase.w
  frcount.b
  sequence.l
  seqindex.b
  enabled.b
End NEWTYPE

; -----------------------------------------------
; Estructura para el personaje y posibles estados
; -----------------------------------------------
;
NEWTYPE .TSprite
  stype.b               ; Tipo de Sprite
  x.w : y.w             ; Coordenadas
  state.b               ; Estado
  stairtype.b           ; Tipo de escalera en que se encuentra
  object.b              ; Tipo de objeto que porta
  counter1.w            ; Iterador#1
  counter2.w            ; Iterador#2
  counter3.w            ; Iterador#3
  flip.b                ; Si esta volteado o no
  flipoffset.b          ; Offset de volteado
  enabled.b             ; Si esta habilitado
  animation.TAnimation  ; Secuencia de animacion
  timer.TTimer          ; Temporizador
  ystair.b              ; Posicion Y inicial de la escalera
  vel_walk.b            ; Velocidad andar
  vel_stairs.b          ; Velocidad subir, bajar escaleras
  teleport.b            ; Si es true, buscar lugar para reaparecer
End NEWTYPE

; ----------------------------------
; Identificadores de tipos de Sprite
; ----------------------------------
;
#spt_Explorer=0     ; Explorador
#spt_Dagger=1       ; Daga
#spt_Mummy_white=2  ; Momia blanca
#spt_Mummy_blue=3   ; Momia azul
#spt_Mummy_yellow=4 ; Momia amarilla
#spt_Mummy_orange=5 ; Momia naranja
#spt_Mummy_red=6    ; Momia roja

; ---------------------------------------
; Estados comunes para Explorador y Momia
; ---------------------------------------
;
#stSpr_init=0        ; Inicializando
#stSpr_walk=1        ; Andando
#stSpr_onstairs=2    ; En una escalera
#stSpr_falling=3     ; Cayendo
#stSpr_jump_left=4   ; Saltando izquierda
#stSpr_jump_top=5    ; Saltando arriba
#stSpr_jump_right=6  ; Saltando derecha

#Spr_arcjump=30      ; Iteraciones del arco de salto

; -------------------------------------
; Valores constantes para el Explorador
; -------------------------------------
;
#Exp_flipoff = 21   ; Offset a sumar para obtener flipX
#Exp_vel_walk = 1   ; Velocidad Andar
#Exp_vel_fall = 4   ; Velocidad Caer

#stEx_picking=10    ; Picando
#stEx_throwdagger=11; Lanzando daga
#stEx_dying=12      ; Muriendo
#stEx_die=13        ; Muerto
#stEx_giratory=14   ; En puerta giratoria
#stEx_goingout=15   ; Saliendo de la piramide
#stEx_leveldone=16  ; Ha superado el nivel

; ----------------------------------
; Valores constantes para las momias
; ----------------------------------
;
#Mum_flipoff=11     ; Offset a sumar para obtener flipX
#Mum_vel_fall=4     ; Velocidad de caida
#Mum_vel_jump=1     ; Velocidad de salto
#stMum_waiting=10   ; Esperando y decidiendo
#stMum_limbus=11    ; Antes de aparecer
#stMum_appearing=12 ; Apareciendo
#stMum_dying=13     ; Muriendo

; ---------------------------------
; Valores constantes para las dagas
; ---------------------------------
;
#Dagger_speed=4
#Dagger_flipoff=8   ; Offset a sumar para obtener flipX
#stDag_throw=0
#stDag_stop=1
#stDag_fall=2

; Estructura para las puertas de entrada/salida y giratorias
;
NEWTYPE .TDoor
  otype.b
  x.b:y.b
  height.b
  frame.b
  state.b
  counter1.b
  doortype.b
  enabled.b
  backbuff.b
End NEWTYPE

; Tipos de puerta
;
#doort_in=0
#doort_out=1
#doort_inout=2

#stDoor_entering=0
#stDoor_closing=1
#stDoor_closed=2
#stDoor_showforexit=3
#stDoor_waitingopen=4
#stDoor_opening=5
#stDoor_openforexit=6

; ------------------
; Variables Globales
; ------------------

.Variables

; ----------------------------------------------
; Contador de tiempo
; Esta variable se incrementa cada 1/60 segundos
; dentro de una interrupcion de barrido vertical
; No debe modificarse nunca, solo leerse
; ----------------------------------------------
;
TIMER_COUNTER.l=0
FRAME_COUNTER.b=0

; -----------------------
; Fotogramas Base Sprites
; -----------------------
;
frmExp_base.w = #BaseSprites         ; Fotograma base personaje
frmExp_pick.w = #BaseSprites+6       ; Fotograma base con pico
frmExp_picking.w = #BaseSprites+19   ; Fotograma base picando
frmExp_dagger.w = #BaseSprites+12    ; Fotograma base con daga
frmExp_die.w = #BaseSprites+42       ; Fotograma base muerte
frm_dagger.w = #BaseSprites+46       ; Fotograma base daga
frmMummy_white.w = #BaseSprites+62   ; Fotograma base momia blanca
frmMummy_blue.w = #BaseSprites+82    ; Fotograma base momia azul
frmMummy_orange.w = #BaseSprites+102 ; Fotograma base momia naranja
frmMummy_yellow.w = #BaseSprites+122 ; Fotograma base momia amarilla
frmMummy_red.w = #BaseSprites+142    ; Fotograma base momia roja
frmMummy_cloud.w = #BaseSprites+162  ; Fotograma base nube de polvo

; Offset de memoria de animaciones
;
MEM_anim_walk.l = ?anim_walk
MEM_anim_throwdagger.l = ?anim_throwdagger
MEM_anim_jump.l = ?anim_jump
MEM_anim_dagger.l = ?anim_dagger
MEM_anim_picking.l = ?anim_picking
MEM_anim_die.l = ?anim_die
MEM_anim_mummy_walk.l = ?mummy_walk
MEM_anim_mummy_jump.l = ?mummy_jump
MEM_anim_mummy_wait.l= ?mummy_wait
MEM_anim_mummy_appear.l= ?mummy_appear
MEM_anim_mummy_die.l= ?mummy_die

; ----------------
; Estado de teclas
; ----------------
;
DEFTYPE.KeyState VKeys   ; Informacion de teclas

; --------------------------
; Informacion de la Piramide
; --------------------------
;
DEFTYPE .TPyramid pyramid
pyramid\w=0
pyramid\h=0
pyramid\back=0
pyramid\front=0
pyramid\work=0
pyramid\jewels=0
Dim List lst_sprites.TSprite(8)
Dim List lst_items.TItem(80)
Dim List lst_jewels.TItem(10)
Dim List lst_walls.TWall(5)
Dim List lst_doors.TDoor(2)
Dim List lst_opdraw.TItem(20)

; Variable para detectar items
;
DEFTYPE.TItem scritem

; Variable para puerta giratoria
;
DEFTYPE.TDoor giradoor

; Variable para la joya que brilla
;
DEFTYPE.TBright jbright

; Variable para obtener donde picar
;
DEFTYPE.TItem pickinfo

; Variable para el Explorador
;
DEFTYPE .TSprite SprExplorer

; Variable para el MedPlayer
;
DEFTYPE .TMedPlayer MedPlayer

; Array de textos de creditos
;
Dim CREDITS.s(20)
CREDITS(00)="KING"+Chr$(39)+"S VALLEY AMIGA VERSION"
CREDITS(01)="M.A SOFTWARE 2021"
CREDITS(02)="DEDICATED TO ALL FRIENDS OF AMIGA"
CREDITS(03)=""
CREDITS(04)="GRAPHICS & SOUNDS:"
CREDITS(05)="TONI GALVEZ "
CREDITS(06)=""
CREDITS(07)="MUSIC:"
CREDITS(08)="NARCISOUND"
CREDITS(09)=""
CREDITS(10)="UTILS & HELP:"
CREDITS(11)="JESUS CHICHARRO"
CREDITS(12)=""
CREDITS(13)="CODING & MORE:"
CREDITS(14)="M.ANGEL JIMENEZ"
CREDITS(15)=""
CREDITS(16)=""
CREDITS(17)=""
CREDITS(18)=""
CREDITS(19)=""

; Puntero a las puertas de la piramide
;
*PInDoor.TDoor=0
*POutDoor.TDoor=0
*PEnterDoor.TDoor=0

; Contadores de puntos, vidas y niveles
;
HIGHSCORE.l=0
SCORE.l=0
LIVES.b=3
LAST_LEVEL.b=0
EXIT_GAME.b=False
CLASSIC_SOUNDSET.b=True
TRICK_INMUNITY.b=False

; Seguimiento de la camara para el scroll
;
CameraX.w=0

; Array de parabola de salto
;
Dim JumpArc.b(#Spr_arcjump)
For i=0 To #Spr_arcjump-1
  JumpArc(i)=Sin(i*Pi/#Spr_arcjump)*22
Next

; --------------------------
; Funciones y procedimientos
; --------------------------
.Procedures

; --------------------------------------------------
; Crea un Rainbow a partir de los datos indicados
; en la estructura .TRainbow pasada como parametro
;
Statement makeRainbow{prainbow.l}
  *P.TRainbow = prainbow
  USEPATH *P
  BLITZ
  For y=\y0 To \y1-1
    r = (\r1-\r0)/(\y1-\y0)*(y-\y1)+\r1
    g = (\g1-\g0)/(\y1-\y0)*(y-\y1)+\g1
    b = (\b1-\b0)/(\y1-\y0)*(y-\y1)+\b1
    ColSplit \cindex,Int(r),Int(g),Int(b),y
  Next
  ColSplit \cindex,0,0,0,\y1
End Statement

; Inicializa un temporizador. 60sexag es 1segundo
;
Statement initTimer{ttimer.l,sexag.w}
  SHARED TIMER_COUNTER
  *Pt.TTimer=ttimer
  USEPATH *Pt
  \toptimer = TIMER_COUNTER+sexag
  \sexages = sexag
End Statement

; Reinicia el temporizador al tiempo configurado previamente
;
Statement restartTimer{ttimer.l}
  SHARED TIMER_COUNTER
  *Pt.TTimer=ttimer
  USEPATH *Pt
  \toptimer = TIMER_COUNTER + \sexages
End Statement

; Comprueba si ya ha pasado el tiempo configurado
;
Function isTimerOut{ttimer.l}
  SHARED TIMER_COUNTER
  *Pt.TTimer=ttimer
  USEPATH *Pt
  Function Return (\toptimer<TIMER_COUNTER)
End Function

; Prepara el MED para que reproduzca a partir de un PATTERN especifico
; si se especifica un waittime se reproduce la musica y se
; detiene pasado ese tiempo
;
Statement startMusic{music,waittime,mask}
  SHARED MedPlayer
  DEFTYPE.TTimer timer
  StopMed
  MedPlayer\playing = True
  MedPlayer\mask=mask
  MedPlayer\music=music
  StartMedModule #Med_music
  If mask>0
    SetMedMask mask
  End If
  JumpMed music
  If waittime>0
    initTimer{timer,waittime}
    Repeat
      VWait
      PlayMed
    Until isTimerOut{timer}=True
    StopMed
    MedPlayer\playing=False
  End If
End Statement

Statement playMusic{}
  SHARED MedPlayer
  If MedPlayer\playing=True Then PlayMed
End Statement

Statement resumeMusic{}
  SHARED MedPlayer
  If MedPlayer\playing
    Statement Return
  End If
  startMusic{MedPlayer\music,0,MedPlayer\mask}
End Statement

Statement stopMusic{}
  SHARED MedPlayer
  If MedPlayer\playing=True
    StopMed
    MedPlayer\playing=False
  End If
End Statement

Statement updateScore{points}
  SHARED pyramid
  SHARED HIGHSCORE,SCORE,LIVES

  If ( Int(SCORE/10000) < Int((SCORE+points)/10000)) AND LIVES<99
    LIVES+1
  End If

  SCORE+points
  If HIGHSCORE<SCORE Then HIGHSCORE=SCORE

  BLITZ
  BitMapOutput #BufferC
  Colour 15,0
  Locate 5,0
  str.s=Str$(SCORE)
  Print "SCORE-"+String$("0",6-Len(str))+str
  str.s=Str$(HIGHSCORE)
  Print " HI-"+String$("0",6-Len(str))+str
  str.s=Str$(LIVES)
  Print " REST-"+String$("0",2-Len(str))+str
  Locate 15,1
  str.s=Str$(pyramid\level)
  str.s=String$("0",2-Len(str))+str
  Print "PYRAMID-"+str

End Statement

Statement playsound{snd.b}
  Sound snd,#FxSoundMask
End Statement

; Actualiza las teclas virtuales
;
Statement updateVKeys{}
  SHARED VKeys
  VKeys\left=(Joyx(1)<0 OR RawStatus($4f)<0)
  VKeys\right=(Joyx(1)>0 OR RawStatus($4e)<0)
  VKeys\up=(Joyy(1)<0 OR RawStatus($4c)<0)
  VKeys\down=(Joyy(1)>0 OR RawStatus($4d)<0)
  VKeys\fire=(Joyb(1)<>0 OR RawStatus($40)<0 OR RawStatus($44)<0)
  VKeys\esc=(RawStatus($45)<0)
End Statement

Statement releaseVKeys{}
  SHARED VKeys
  VKeys\left=False
  VKeys\right=False
  VKeys\up=False
  VKeys\down=False
  VKeys\fire=False
  VKeys\esc=False
  VKeys\keydown=False
End Statement

; Lee teclas virtuales, y hasta que no se liberen no vuelve
; a leerlas
;
Statement updateVKeysWithRelease{}
  SHARED VKeys
  USEPATH VKeys
  count.b=0
  If (Joyx(1)<0 OR RawStatus($4f)<0)
    \left=(\keydown=False)
    count+1
  Else
    \left=False
  End If
  If (Joyx(1)>0 OR RawStatus($4e)<0)
    \right=(\keydown=False)
    count+1
  Else
    \right=False
  End If
  If (Joyy(1)<0 OR RawStatus($4c)<0)
    \up=(\keydown=False)
    count+1
  Else
    \up=False
  End If
  If (Joyy(1)>0 OR RawStatus($4d)<0)
    \down=(\keydown=False)
    count+1
  Else
    \down=False
  End If
  If (Joyb(1)<>0 OR RawStatus($40)<0 OR RawStatus($44)<0)
    \fire=(\keydown=False)
    count+1
  Else
    \fire=False
  End If
  If (RawStatus($45)<0)
    \esc=(\keydown=False)
    count+1
  Else
    \esc=False
  End If
  \keydown=(count>0)
End Statement

Function gettileid{x.b,y.b,layer.l}
  SHARED pyramid
  offset.l=layer+y*pyramid\w+x
  Function Return Peek.b(offset)&$FF
End Function

Statement puttileid{x.b,y.b,layer.l,id.b}
  SHARED pyramid
  offset.l = layer + y*pyramid\w + x
  Poke.b offset,id&$ff
End Statement

; Checkea si el codigo del item detectado con la cabeza
; se corresponde con pico o pulsadores de puertas
;
Function checkItemHead{item.b}
  Select item&$ff
    Case #It_picker
    Case #It_push_in
    Case #It_push_out
    Default
      Function Return False
  End Select
  Function Return True
End Function

; Checkea si el codigo del item detecado con los pies
; se corresponde con el pico, daga, joya, escaleras
; de subida o puertas giratorias
;
Function checkItemFoot{item.b}
  Select item&$ff
    Case #It_picker
    Case #It_dagger
    Case #It_jewel
    Case #It_stair_ur
    Case #It_stair_ul
    Case #It_rgiratory
    Case #It_lgiratory
    Default
      Function Return False
  End Select
  Function Return True
End Function

; Checkea si el codigo del item detectado por debajo de los pies
; se corresponde con escaleras para bajar
;
Function checkItemDownfoot{item.b}
  Select item&$ff
    Case #It_stairs
    Case #It_stair_dl
    Case #It_stair_dr
    Default
      Function Return False
  End Select
  Function Return True
End Function

; Checkea si el codigo del item indicado
; se corresponde con Ladrillo o Escaleras
; que no serian transpasables
;
Function checkItemSolid{item.b}
  Select item&$ff
    Case #It_brick
    Case #It_stairs
    Case #It_stair_dl
    Case #It_stair_dr
    Default
      Function Return False
  End Select
  Function Return True
End Function

Statement addopdraw{opdraw.l}
  SHARED lst_opdraw()
  *Pod.TItem = opdraw
  ret=AddItem(lst_opdraw())
  lst_opdraw()\otype = *Pod\otype
  lst_opdraw()\x = *Pod\x
  lst_opdraw()\y = *Pod\y
  lst_opdraw()\p0 = *Pod\p0
  lst_opdraw()\p1 = *Pod\p1
  lst_opdraw()\work = *Pod\work
  lst_opdraw()\buffc = 2
End Statement

Function canMoveRight{x.w,y.w,vel.b}
  SHARED pyramid
  cx.b=(x.w + 8 + vel)/10
  cy.b=y.w/10
  t.b = gettileid{cx,cy,pyramid\work}
  If checkItemSolid{t}=True
     Function Return False
  End If
  cy-1
  t.b = gettileid{cx,cy,pyramid\work}
  If checkItemSolid{t}=True
    Function Return False
  End If
  Function Return True
End Function

Function canMoveLeft{x.w,y.w,vel.b}
  SHARED pyramid
  cx.b=(x.w - 8 - vel)/10
  cy.b=y.w/10
  t.b = gettileid{cx,cy,pyramid\work}
  If checkItemSolid{t}=True
     Function Return False
  End If
  cy-1
  t.b = gettileid{cx,cy,pyramid\work}
  If checkItemSolid{t}=True
    Function Return False
  End If
  Function Return True
End Function

Function canJump{x.w,y.w,direction.b}
  SHARED pyramid
  cx.b=(x.w - 4)/10
  cy.b=(y.w / 10)-2
  If (cy<=0)
    Function Return True
  End If
  t.b = gettileid{cx,cy,pyramid\work}
  If checkItemSolid{t}=True
     Function Return False
  End If
  cx.b=(x.w + 4)/10
  t.b = gettileid{cx,cy,pyramid\work}
  If checkItemSolid{t}=True
     Function Return False
  End If
  If direction<>0
    cx.b = (x.w / 10) + direction
    cy.b = (y.w / 10) - 2
    t.b = gettileid{cx,cy,pyramid\work}
    If checkItemSolid{t}=True
      Function Return False
    End If
  End If
  Function Return True
End Function

Function canFall{x.w,y.w,vel.b}
  SHARED pyramid
  cx.b=(x.w - 4)/10
  cy.b=(y.w+vel.b)/10
  t.b = gettileid{cx,cy,pyramid\work}
  If checkItemSolid{t}=True
     Function Return False
  End If
  cx.b=(x.w + 4)/10
  t.b = gettileid{cx,cy,pyramid\work}
  If checkItemSolid{t}=True
     Function Return False
  End If
  Function Return True
End Function

Statement centerCellX{spr.l}
  *Pspr.TSprite = spr
  USEPATH *Pspr
  \x = \x/10 * 10 + 5
End Statement

Statement centerCellY{spr.l}
  *Pspr.TSprite = spr
  USEPATH *Pspr
  \y = \y/10 * 10 + 9
End Statement

Statement whereCanPick{}
  SHARED SprExplorer,pyramid,pickinfo
  USEPATH pickinfo
  cy.b=(SprExplorer\y / 10)
  cx.b=(SprExplorer\x / 10)
  \otype=#It_none

  ; Determinamos si esta encerrado
  closed.b = False
  If gettileid{cx-1,cy-1,pyramid\work}=#It_brick
    If gettileid{cx+1,cy-1,pyramid\work}=#It_brick
      closed=True
    End If
  End If

  ; Si esta encerrado, debe picar primero para los lados
  ; a menos que este en el limite de la piramide
  ;
  If closed
    If SprExplorer\flip
      If cx<=1
        Statement Return
      Else
        ; Indicamos la coordenada donde puede picar
        ; a la izquierda, y si sera 1 o 2 cuadros
        ;
        \otype=#It_picker
        \x=cx-1 : \y=cy-1 : \p0=1
        If gettileid{cx-1,cy,pyramid\work}=#It_brick
          \p0=2
        End If
        Statement Return
      End If
    Else
      If cx>=pyramid\w-2
        Statement Return
      Else
        ; Indicamos la coordenada donde puede picar
        ; a la derecha, y si sera 1 o 2 cuadros
        ;
        \otype=#It_picker
        \x=cx+1 : \y=cy-1 : \p0=1
        If gettileid{cx+1,cy,pyramid\work}=#It_brick
          \p0=2
        End If
        Statement Return
      End If
    End If
  End If

  ; Como no esta encerrado, debe picar en el suelo
  ; No se puede picar en los limites de la piramide
  ;
  If SprExplorer\flip AND cx<=1
    Statement Return
  End If
  If cx>=pyramid\w-2 OR cy>=pyramid\h-2
    Statement Return
  End If

  ; Corregimos la celdilla, segun flip
  ;
  If SprExplorer\flip
    cx.b-1
  Else
    cx.b+1
  End If

  ; No se puede picar encima de una puerta giratoria
  ;
  If gettileid{cx,cy+2,pyramid\work}=#It_rgiratory OR gettileid{cx-1,cy+2,pyramid\work}=#It_rgiratory
    Statement Return
  End If
  If gettileid{cx,cy+2,pyramid\work}=#It_lgiratory OR gettileid{cx+1,cy+2,pyramid\work}=#It_lgiratory
    Statement Return
  End If

  ; Si delante hay un muro, no se puede picar
  ;
  If gettileid{cx,cy,pyramid\work}=#It_brick
    Statement Return
  End If

  ; Si debajo no hay un muro, no se puede picar
  ;
  If gettileid{cx,cy+1,pyramid\work}<>#It_brick
    Statement Return
  End If

  ; Vamos a poder picar
  ;
  \otype=#It_picker
  \x=cx : \y=cy+1 : \p0=1
  If (cy<pyramid\h-3) AND gettileid{cx,cy+2,pyramid\work}=#It_brick
    \p0=2
  End If
End Statement

; Detecta picos, joyas, escaleras
; primero por abajo, y luego por arriba
;
Function detectExplorerItem{x.w,y.w,item.l}
  SHARED pyramid
  *Pitem.TItem = item
  *Pitem\buffc=0
  *Pitem\work=0
  *Pitem\p0=0
  *Pitem\p1=0
  cx.b = x.w / 10
  cy.b = y.w / 10
  If Int(Rnd(2))=0
    t.b = gettileid{cx,cy,pyramid\work}
    If checkItemFoot{t}=True
     *Pitem\x=cx
     *Pitem\y=cy
     *Pitem\otype=t
     Function Return True
    End If
  End If
  cy.b = (y.w-18) / 10
  t.b = gettileid{cx,cy,pyramid\work}
  If checkItemHead{t}=True
     *Pitem\x=cx
     *Pitem\y=cy
     *Pitem\otype=t
     Function Return True
  End If
  cy.b = (y.w+2) / 10
  t.b = gettileid{cx,cy,pyramid\work}
  If checkItemDownfoot{t}
     *Pitem\x=cx
     *Pitem\y=cy
     *Pitem\otype=t
     Function Return True
  End If
  Function Return False
End Function

; Detecta escaleras para las momias
;
Function detectMummyItem{x.w,y.w,item.l}
  SHARED pyramid
  *Pitem.TItem = item
  *Pitem\buffc=0
  *Pitem\work=0
  *Pitem\p0=0
  *Pitem\p1=0
  cx.b = x.w / 10
  cy.b = y.w / 10
  If Int(Rnd(2))=0
    t.b = gettileid{cx,cy,pyramid\work}
    If checkItemFoot{t}=True
     *Pitem\x=cx
     *Pitem\y=cy
     *Pitem\otype=t
     Function Return True
    End If
  End If
  cy.b = (y.w+2) / 10
  t.b = gettileid{cx,cy,pyramid\work}
  If checkItemDownfoot{t}
     *Pitem\x=cx
     *Pitem\y=cy
     *Pitem\otype=t
     Function Return True
  End If
  Function Return False
End Function

Statement setAnimation{animation.l,animseq.l,frmbase.w}
  *Panim.TAnimation=animation
  *Panim\sequence=animseq
  *Panim\seqindex=1
  *Panim\framebase=frmbase
  *Panim\frame=Peek.b(animseq)+frmbase
  *Panim\frcount=Peek.b(animseq+1)
End Statement

Statement restartAnimation{animation.l}
  *Panim.TAnimation=animation
  USEPATH *Panim
  If \seqindex>1
    \seqindex=1
    \frame=Peek.b(\sequence)+\framebase
    \frcount=Peek.b(\sequence+1)
  End If
End Statement

Function doAnimation{animation.l}
  *Panim.TAnimation=animation
  USEPATH *Panim
  ret.b=True
  \frcount-1
  If \frcount<1
    \seqindex+1
    \frame=Peek.b(\sequence+\seqindex)
    If (\frame<0)
      \seqindex=0
      \frame=Peek.b(\sequence)
      ret.b=False
    End If
    \seqindex+1
    \frcount=Peek.b(\sequence+\seqindex)
    \frame+\framebase
  End If
  Function Return ret
End Function

Statement throwdagger{x.w,y.w,flp.b}
  SHARED lst_sprites(),frm_dagger,MEM_anim_dagger
  ret=AddItem(lst_sprites())
  USEPATH lst_sprites()
  \stype=#spt_Dagger
  \x=x
  \y=y
  \flip=flp
  \flipoffset=#Dagger_flipoff
  \animation\enabled=True
  \enabled=True
  \state=#stDag_throw
  setAnimation{\animation,MEM_anim_dagger,frm_dagger}
End Statement

Statement stopDagger{dagger.l}
  *Pdag.TSprite=dagger
  USEPATH *Pdag
  \state = #stDag_stop
  \flip=1-\flip
  \counter1 = 8
End Statement

Statement doMoveDagger{dagger.l}
  SHARED pyramid
  *Pdag.TSprite=dagger
  ct.b : cx.b : cy.b
  USEPATH *Pdag
  r=doAnimation{\animation}
  Select \state
    Case #stDag_throw
      If \flip
        cy = \y / 10
        cx = (\x - #Dagger_speed)/10
        ct=gettileid{cx,cy,pyramid\work}
        If ct<>#It_brick
          \x - #Dagger_speed
        Else
          stopDagger{dagger}
        End If
      Else
        cy = \y / 10
        cx = (\x + #Dagger_speed)/10
        ct=gettileid{cx,cy,pyramid\work}
        If ct<>#It_brick
          \x + #Dagger_speed
        Else
          stopDagger{dagger}
        End If
      End If

    Case #stDag_stop
      \counter1-1
      If \flip
        \x-1
      Else
        \x+1
      End If
      If \counter1=0 Then \state=#stDag_fall

    Case #stDag_fall
      cy = (\y + #Dagger_speed) / 10
      cx = \x /10
      ct = gettileid{cx,cy,pyramid\work}
      If checkItemSolid{ct}=True
        ; Ha tocado el suelo, no debe haber nada para clavarse
        cy-1
        DEFTYPE.TItem litem
        litem\otype=#It_dagger
        litem\p1=#Tile_dagger
        litem\work=#It_dagger
        For x=0 To 6
          If (cx-x > 0)
            If gettileid{cx-x,cy,pyramid\work}=0
              ; nos aseguramos que cae en suelo
              While checkItemSolid{gettileid{cx-x,cy+1,pyramid\work}}=False
                cy+1
              Wend
              litem\x=cx-x
              litem\y=cy
              litem\p0=gettileid{litem\x,litem\y,pyramid\front}
              addopdraw{litem}
              \enabled=False
              Statement Return
            End If
          End If
          If (x>0 AND cx+x < 63)
            If gettileid{cx+x,cy,pyramid\work}=0
              While checkItemSolid{gettileid{cx-x,cy+1,pyramid\work}}=False
                cy+1
              Wend
              litem\x=cx+x
              litem\y=cy
              litem\p0=gettileid{litem\x,litem\y,pyramid\front}
              addopdraw{litem}
              \enabled=False
              Statement Return
            End If
          End If
        Next
      Else
        \y+#Dagger_speed
      EndIf
  End Select
End Statement

; Establece la animacion del explorador en funcion
; de su estado, y del objeto que porte
;
Statement setExplorerAnimation{}
  SHARED SprExplorer,frmExp_base,frmExp_pick,frmExp_dagger
  SHARED frmExp_picking,frmExp_die
  SHARED MEM_anim_walk,MEM_anim_jump,MEM_anim_picking
  SHARED MEM_anim_die,MEM_anim_throwdagger

  baseanim.w=0
  Select SprExplorer\object
    Case #It_none
      baseanim=frmExp_base
    Case #It_picker
      baseanim=frmExp_pick
    Case #It_dagger
      baseanim=frmExp_dagger
  End Select

  If SprExplorer\state<#stSpr_jump_left OR SprExplorer\state=#stEx_goingout
    setAnimation{SprExplorer\animation,MEM_anim_walk,baseanim}
  Else
    If SprExplorer\state<=#stSpr_jump_right
      setAnimation{SprExplorer\animation,MEM_anim_jump,baseanim}
    Else
      Select SprExplorer\state
        Case #stEx_picking
          setAnimation{SprExplorer\animation,MEM_anim_picking,frmExp_picking}
        Case #stEx_throwdagger
          setAnimation{SprExplorer\animation,MEM_anim_throwdagger,baseanim}
        Case #stEx_dying
          SprExplorer\flip=0
          setAnimation{SprExplorer\animation,MEM_anim_die,frmExp_die}
      End Select
    End If
  End If
  r=doAnimation{SprExplorer\animation}
End Statement

Statement setExplorer{frompyramid}
  SHARED lst_doors(),SprExplorer,pyramid
  SHARED *PInDoor,*POutDoor,*PEnterDoor
  iterate.b=0
  *PInDoor=0
  *POutDoor=0
  *PEnterDoor=0
  ResetList lst_doors()
  Repeat
    iterate = NextItem(lst_doors())
    If iterate
      If lst_doors()\doortype=#doort_in OR lst_doors()\doortype=#doort_inout
        *PInDoor=lst_doors()
        If frompyramid<pyramid\level OR lst_doors()\doortype=#doort_inout
          *PEnterDoor=lst_doors()
        End If
      Else
        *POutDoor=lst_doors()
        If frompyramid>pyramid\level Then *PEnterDoor=lst_doors()
      End If
      lst_doors()\enabled=False
      lst_doors()\state=#stDoor_entering
      lst_doors()\counter1=0
    End If
  Until iterate=False

  ; Obtenemos los fondos de la zona que ocupan las puertas
  ;
  *PInDoor\backbuff=#BufferDoor1
  If *POutDoor<>*PInDor
    *POutDoor\backbuff=#BufferDoor2
  End If

  SprExplorer\x = (*PEnterDoor\x + 2)*10
  SprExplorer\y = (*PEnterDoor\y + 3)*10-1
  SprExplorer\flip=0
  SprExplorer\state=#stSpr_walk
  SprExplorer\object=#It_none
  setExplorerAnimation{}
  *PEnterDoor\enabled=True
End Statement

Statement setMummyAnimation{mummy.l}
  SHARED MEM_anim_mummy_walk,MEM_anim_mummy_jump
  SHARED MEM_anim_mummy_wait,MEM_anim_mummy_appear
  SHARED MEM_anim_mummy_die
  SHARED frmMummy_white,frmMummy_blue,frmMummy_yellow
  SHARED frmMummy_orange,frmMummy_red,frmMummy_cloud

  *mum.TSprite=mummy
  baseanim.w
  USEPATH *mum

  Select \stype
    Case #spt_Mummy_white
      baseanim = frmMummy_white
    Case #spt_Mummy_blue
      baseanim = frmMummy_blue
    Case #spt_Mummy_yellow
      baseanim = frmMummy_yellow
    Case #spt_Mummy_orange
      baseanim = frmMummy_orange
    Case #spt_Mummy_red
      baseanim = frmMummy_red
  End Select

  Select \state
    Case #stSpr_walk
      setAnimation{\animation,MEM_anim_mummy_walk,baseanim}
    Case #stSpr_falling
      setAnimation{\animation,MEM_anim_mummy_jump,baseanim}
    Case #stSpr_jump_left
      setAnimation{\animation,MEM_anim_mummy_jump,baseanim}
    Case #stSpr_jump_top
      setAnimation{\animation,MEM_anim_mummy_jump,baseanim}
    Case #stSpr_jump_right
      setAnimation{\animation,MEM_anim_mummy_jump,baseanim}
    Case #stMum_limbus
      setAnimation{\animation,MEM_anim_mummy_jump,baseanim}
    Case #stMum_appearing
      setAnimation{\animation,MEM_anim_mummy_appear,frmMummy_cloud}
    Case #stMum_waiting
      \flip=0
      setAnimation{\animation,MEM_anim_mummy_wait,baseanim}
    Case #stMum_dying
      setAnimation{\animation,MEM_anim_mummy_die,frmMummy_cloud}
  End Select
  r=doAnimation{\animation}
End Statement

Statement killExplorer{}
  SHARED SprExplorer
  SprExplorer\state=#stEx_dying
  setExplorerAnimation{}
  stopMusic{}
  playsound{#Snd_dead}
End Statement

; Prepara el Sprite para hacer un salto
;
Statement initJump{spr.l,state.b}
  *Spr.TSprite=spr
  *Spr\counter1=0
  *Spr\counter2=*Spr\y
  *Spr\state=state
End Statement

; Realiza el salto de un sprite
;
Statement doJump{spr.l,vel_walk.b,vel_fall.b}
  SHARED JumpArc()
  *Pspr.TSprite = spr
  USEPATH *Pspr

  ; Arco de Salto
  If \counter1<#Spr_arcjump
    \y = \counter2 - JumpArc(\counter1)
    If \counter1>#Spr_arcjump/2 AND canFall{\x,\y,vel_fall}=False
      \counter1=#Spr_arcjump
    Else
      \counter1+1
    End If
  Else
    If canFall{\x,\y,vel_fall}=True
      \y+vel_fall
    Else
      \state=#stSpr_falling
    End If
  End If

  Select \state
    Case #stSpr_jump_left
      If canMoveLeft{\x,\y,vel_walk}
        \x-vel_walk
      End If
    Case #stSpr_jump_right
      If canMoveRight{\x,\y,vel_walk}
        \x+vel_walk
      End If
  End Select

End Statement

; Controla movimiento de sprite en escalera
;
Statement doControlStair{spr.l,mleft.b,mright.b,vel_walk.b}
  SHARED pyramid
  *Pspr.TSprite = spr
  USEPATH *Pspr
  ; Control lateral
  ;
  If \stairtype=#It_stair_ur OR \stairtype=#It_stair_dl
    If mleft
      \flip=1
      r=doAnimation{\animation}
      ct.b=gettileid{\x / 10, (\y-4) / 10,pyramid\work}
      If ct.b>0 AND ct.b=#It_stair_ur
        \x=(\x / 10)*10+5
        \y=((\y-4) / 10)*10+9
        \state = #stSpr_walk
      Else
        \x-vel_walk
        \y+vel_walk
      End If
    Else
      If mright
        \flip=0
        r=doAnimation{\animation}
        ct.b=gettileid{(\x/ 10), (\y / 10),pyramid\work}
        If ct.b<>#It_stair_ur
          ct.b=gettileid{(\x/ 10)-1, (\y / 10)+1,pyramid\work}
        Else
          If gettileid{(\x/ 10)-1, (\y / 10)+1,pyramid\work}=#It_stair_dl AND (\y / 10)<>*Pspr\ystair
            ct.b=#It_stair_dl
          End If
        End If
        If ct.b>0 AND ct.b=#It_stair_dl
          \x = (\x /10) * 10
          \y = (\y /10) * 10 + 9
          \state = #stSpr_walk
        Else
          \x+vel_walk
          \y-vel_walk
        End If
      Else
        restartAnimation{\animation}
      End If
    End If
  Else
    If \stairtype=#It_stair_ul OR \stairtype=#It_stair_dr
      If mright
        \flip=0
        r=doAnimation{\animation}
        ct.b = gettileid{\x / 10, (\y-4) / 10,pyramid\work}
        If ct.b>0 AND ct.b=#It_stair_ul
          \x=(\x / 10)*10+5
          \y=((\y-4) / 10)*10+9
          \state = #stSpr_walk
        Else
          \x+vel_walk
          \y+vel_walk
        End If
      Else
        If mleft
          \flip=1
          r=doAnimation{\animation}
          ct.b=gettileid{(\x/ 10), (\y / 10),pyramid\work}
          If ct.b<>#It_stair_ul
            ct.b=gettileid{(\x / 10)+1, (\y / 10)+1,pyramid\work}
          Else
            If gettileid{(\x / 10)+1, (\y / 10)+1,pyramid\work}=#It_stair_dr AND (\y / 10)<>*Pspr\ystair
              ct.b=#It_stair_dr
            End If
          End If
          If ct.b>0 AND ct.b=#It_stair_dr
            \x=(\x / 10)*10+5
            \y = (\y / 10) * 10 + 9
            \state = #stSpr_walk
          Else
            \x-vel_walk
            \y-vel_walk
          End If
        Else
          restartAnimation{\animation}
        End If
      End If
    End If
  End If
End Statement

; De las joyas aun no cogidas, selecciona una para
; hacer efecto de brillo
;
Statement getBrightJewel{pbright.l}
  SHARED pyramid,lst_jewels()

  *Pbright.TBright=pbright
  *Pbright\pjewel=0

  ; Si ya no quedan joyas, no hacemos nada.
  ;
  If pyramid\jewels<1 Then Statement Return

  ; Si solo queda una joya, esa es la que brilla.
  ;
  If pyramid\jewels=1
    jw.b = 1
  Else
    ; Obtenemos al azar una de las joyas
    ; hacemos 3 lecturas, para tener mas aleatoriedad
    jw.b = Int(Rnd(pyramid\jewels))+1
    jw.b = Int(Rnd(pyramid\jewels))+1
    jw.b = Int(Rnd(pyramid\jewels))+1
  End If

  ResetList lst_jewels()
  While NextItem(lst_jewels()) AND jw.b>0
    USEPATH lst_jewels()
    If \enabled
      If jw.b=1
        *Pbright\pjewel=lst_jewels()
        \p1=0 ; contador de iteracion de brillo
      End If
      jw.b-1
    End If
  Wend

End Statement

Statement disableJewel{pitem.l}
  SHARED lst_jewels(),pyramid
  *Pitem.TItem=pitem
  ResetList lst_jewels()
  While NextItem(lst_jewels())
    USEPATH lst_jewels()
    If \x=*Pitem\x AND \y=*Pitem\y AND \enabled
      \enabled=False
    End If
  Wend
End Statement

; Inicia el giro de la puerta giratoria
; localizando su posicion correcta y tipo a partir del tile
; detectado
;
Statement startGiratoryDoor{pitem.l}
  SHARED giradoor,SprExplorer,pyramid
  *Pitem.TItem=pitem
  USEPATH *Pitem

  giradoor\frame=0
  giradoor\counter1=0
  giradoor\otype=\otype

  ; Buscamos la coordenada y superior
  cy.b=\y
  While gettileid{\x,cy,pyramid\work}=\otype
    cy-1
  Wend
  cy+1
  giradoor\y=cy

  ; Buscamos la coordeanda inferior para calcular la altura
  cy=\y
  While gettileid{\x,cy,pyramid\work}=\otype
    cy+1
  Wend
  cy-1
  giradoor\height=cy-giradoor\y+1
  If \otype=#It_rgiratory
    giradoor\x=\x
  Else
    giradoor\x=\x-1
  End If
  giradoor\enabled=True
  SprExplorer\y=cy*10+9
  SprExplorer\state=#stSpr_walk
  setExplorerAnimation{}
End Statement

; Dibuja la animacion de la puerta giratoria
; Es importante que el ultimo fotograma se pinte 2 veces
; uno en cada buffer, por eso aunque counter termina en
; 60, se itera una vez mas para finalizar la animacion
; y volver a pintar.
;
Statement drawGiratory{}
  SHARED pyramid,SprExplorer,giradoor

  USEPATH giradoor

  ; Se itera de 0 a 29, para mostrar los 10 fotogramas
  ; de la animacion. Cuando se llegue a 30, es el ultimo paso
  ; donde se actualiza "work" y se pinta una ultima vez en el
  ; doble buffer
  ;
  If \counter1<30
    ; Calculamos el fotograma que corresponde pintar
    If \otype = #It_rgiratory
      ;Caso que gira a la derecha
      \frame = #Tile_giratory_toright + (\counter1 / 3)*2
      If (\counter1 MOD 3)=0 Then SprExplorer\x+2
    Else
      ;Caso que gira a la izquierda
      \frame = #Tile_giratory_toleft - (\counter1 / 3)*2
      If (\counter1 MOD 3)=0 Then SprExplorer\x-2
    End If
    r=doAnimation{SprExplorer\animation}
    \counter1+1
  Else
    \enabled=False
    If \otype = #It_rgiratory
      SprExplorer\x+2
    Else
      SprExplorer\x-2
    End If
  End If

  ; borramos la zona que ocupa el grafico
  ;
  BLITZ
  Boxf \x*10,#SafeMargin+\y*10,(\x+2)*10-1,#SafeMargin+(\y+\height)*10-1,#Color_black
  offset.l = pyramid\work + \y*pyramid\w + \x
  ; pintamos los tiles
  For i=\y To \y+\height-1
    Blit #BaseTiles+(\frame&$ff)-1,\x*10,i*10+#SafeMargin
    Blit #BaseTiles+(\frame&$ff),(\x+1)*10,i*10+#SafeMargin
    If \otype=#It_rgiratory
      Poke.b offset,#It_brick
      Poke.b offset+1,#It_lgiratory
      ;puttileid{\x,i,pyramid\work,#It_brick}
      ;puttileid{\x+1,i,pyramid\work,#It_lgiratory}
    Else
      Poke.b offset,#It_rgiratory
      Poke.b offset+1,#It_brick
      ;puttileid{\x,i,pyramid\work,#It_rgiratory}
      ;puttileid{\x+1,i,pyramid\work,#It_brick}
    End If
    offset+pyramid\w
  Next

End Statement

Statement drawDoor{pdoor.l,offsopen.b,push.b,restoreback.b}
  *Pd.TDoor=pdoor
  USEPATH *Pd
  BLITZ

  If restoreback
    Scroll 0,0,50,30,(\x-1)*10,\y*10+#SafeMargin,\backbuff
  End If

  ; Caso que la puerta deba desaparecer
  ;
  If offsopen<0 Then Statement Return

  ; Pintamos la escalerita
  px.w=(\x+1)*10
  py.w=(\y+1)*10+#SafeMargin
  Blit #BaseTiles+#Tile_door,px,py

  ; Pintamos la puerta de la izquierda
  px.w-offsopen
  py.w=\y*10+#SafeMargin
  Blit #BaseTiles+#Tile_doorleft,px,py

  ; Pintamos la puerta de la derecha
  px.w=(\x+2)*10+offsopen
  Blit #BaseTiles+#Tile_doorright,px,py

  ; Pintamos el pulsador
  If push=0
    Blit #BaseTiles+#Tile_push_up-1,(\x-1)*10,py
  Else
    Blit #BaseTiles+#Tile_push_down-1,(\x-1)*10,py
  End If

End Statement

Statement closeDoor{pdoor.l}
  SHARED pyramid
  *Pdoor.TDoor=pdoor.l
  USEPATH *Pdoor
  Select \state
    Case #stDoor_entering
      If \counter1=0
        playsound{#Snd_door}
      End If
      \counter1+1
      If \counter1>=20
        \state=#stDoor_closing
        \counter1=40
      End If
    Case #stDoor_closing
      If \counter1>0
        drawDoor{*Pdoor,\counter1 / 4,0,1}
        \counter1-1
      Else
        \state=#stDoor_closed
        \counter1=2
      End If
    Case #stDoor_closed
      If \counter1>0
        drawDoor{*Pdoor,-1,0,1}
      Else
        *Pdoor\enabled=False
        Select (pyramid\level-1) MOD 3
          Case 0
            startMusic{#Med_music1,0,7}
          Case 1
            startMusic{#Med_music2,0,7}
          Case 2
            startMusic{#Med_music3,0,7}
        End Select
      End If
      \counter1-1
  End Select
End Statement

Statement openDoor{pdoor.l}
  *Pdoor.TDoor=pdoor.l
  USEPATH *Pdoor
  If \state=#stDoor_opening
    If \counter1<20
      drawDoor{*Pdoor,\counter1 / 2,0,1}
      \counter1+1
    Else
      ; Terminamos de actualizar los 2 buffers
      ;
      If \counter1<22
        drawDoor{*Pdoor,10,0,1}
        \counter1+1
      Else
        \state=#stDoor_openforexit
        \counter1=0
      End If
    End If
  End If
End Statement

Statement showDoorsForExit{}
  SHARED *PInDoor,*POutDoor,pyramid
  If *PInDoor<>0
    *PInDoor\state=#stDoor_showforexit
    *PInDoor\counter1=0
    *PInDoor\enabled=True
    puttileid{*PInDoor\x-1,*PInDoor\y,pyramid\work,#It_push_in}
  End If
  If *POutDoor<>0
    *POutDoor\state=#stDoor_showforexit
    *POutDoor\counter1=0
    *POutDoor\enabled=True
    puttileid{*POutDoor\x-1,*POutDoor\y,pyramid\work,#It_push_out}
  End If
End Statement

Statement controlDoor{pdoor.l}
  SHARED SprExplorer,*PEnterDoor
  *Pd.TDoor=pdoor
  USEPATH *Pd
  Select \state
    Case #stDoor_entering
      closeDoor{pdoor}
    Case #stDoor_closing
      closeDoor{pdoor}
    Case #stDoor_closed
      closeDoor{pdoor}
    Case #stDoor_showforexit
      If \counter1<2
        drawDoor{pdoor,0,0,0}
        \counter1+1
      Else
        \state=#stDoor_waitingopen
        \counter1=0
      End If
    Case #stDoor_waitingopen
    Case #stDoor_opening
      openDoor{pdoor}
    Case #stDoor_openforexit
      cx.b = SprExplorer\x / 10
      cy.b = SprExplorer\y / 10
      Blit #BaseTiles+#Tile_push_down-1+(\counter1/10)*2,(\x-1)*10,(\y+2)*10
      \counter1+1
      If \counter1>19 Then \counter1=0
      If cx>\x AND cx<\x+3 AND cy=\y+2 AND SprExplorer\state<>#stEx_goingout
        SprExplorer\state=#stEx_goingout
        SprExplorer\counter1=0
        SprExplorer\x=(\x+2)*10
        SprExplorer\y=(\y+2)*10+9
        SprExplorer\flip=0
        *PEnterDoor=pdoor
        setExplorerAnimation{}
      End If
  End Select
End Statement

Statement doControlWalls{}
  SHARED SprExplorer,pyramid,lst_walls()
  DEFTYPE.TItem item
  ResetList lst_walls()
  USEPATH lst_walls()
  While NextItem(lst_walls())
    If \enabled
      cx.b = SprExplorer\x / 10
      cy.b = SprExplorer\y / 10
      Select \state
        Case #stWall_waiting
          If cx=\x1 AND cy=\y1
            restartTimer{\timer}
            \state=#stWall_closing
            \counter1=\y
          End If
        Case #stWall_closing
          If isTimerOut{\timer}
            If \counter1 < \y1
              \counter1+1
              item\x=\x
              item\y=\counter1
              item\p0=0
              item\p1=\tileid
              item\work=#It_brick
              addopdraw{item}
              restartTimer{\timer}
              ; si el mucho ha chocado con el personaje
              ; lo hacemos morir
              If cx=\x AND cy-1=\counter1
                killExplorer{}
              End If
            Else
              \state=#stWall_closed
            End If
          End If
        Case #stWall_closed
          \enabled=False
      End Select
    End If
  Wend
End Statement


; Mensaje Game Over
;
Statement gameOver{currentBitmap.b}
  SHARED CameraX
  w.b = 11
  h.b = 3
  px.w = (CameraX + 160 - w*8/2)/8
  py.w = (#SafeMargin + 6*8)/8
  Use BitMap currentBitmap
  BitMapOutput currentBitmap
  Boxf px*8,py*8,(px+w)*8-1,(py+h)*8-1,#Color_black
  Box px*8+2,py*8+2,(px+w)*8-3,(py+h)*8-3,#Color_white
  Colour #Color_white,#Color_black
  Locate px+1,py+1: Print "GAME OVER"
  startMusic{#Med_gameover,60*4,15}
End Statement

; Muestra un dialogo de pausa o restar
; durante el juego
;
Function getMenuGameOption{currentBitmap.b}
  SHARED CameraX,VKeys
  w.b = 17
  h.b = 6
  BitMap #BufferD,w*8,h*8,4
  px.w = (CameraX + 160 - w*8/2)/8
  py.w = (#SafeMargin + h*8)/8

  ; Copiamos en el #BufferD el rectangulo
  ; del currentBitmap
  ;
  Use BitMap #BufferD
  Scroll px*8,py*8,w*8,h*8,0,0,currentBitmap

  Use BitMap currentBitmap
  BitMapOutput currentBitmap
  Boxf px*8,py*8,(px+w)*8-1,(py+h)*8-1,#Color_black
  Box px*8+2,py*8+2,(px+w)*8-3,(py+h)*8-3,#Color_white

  Colour #Color_white,#Color_black

  Locate px+1,py+1: Print "SELECT OPTION"
  Locate px+3,py+2: Print "CONTINUE"
  Locate px+3,py+3: Print "RESTART LEVEL"
  Locate px+3,py+4: Print "EXIT GAME"

  option.b=0
  Colour #Color_red,#Color_black

  playsound{#Snd_takejewel}

  Repeat
    updateVKeysWithRelease{}
    VWait
    If VKeys\up AND option>0
      Locate px+1,py+2+option : Print " "
      option-1
    Else
      If VKeys\down AND option<2
        Locate px+1,py+2+option : Print " "
        option+1
      End If
    End If
    Locate px+1,py+2+option : Print ">"
  Until VKeys\fire

  ; Restauramos el currentBitmap
  ;
  Scroll 0,0,w*8,h*8,px*8,py*8,#BufferD
  Free BitMap #BufferD
  releaseVKeys{}
  VWait 10
  Function Return option

End Function

; Obtiene una distancia aproximada entre un Sprite y el Explorador
;
Function distanceExp{spr.l}
  SHARED SprExplorer
  *Spr.TSprite=spr
  Function Return Int((Abs(SprExplorer\x - *Spr\x) + Abs(SprExplorer\y - *Spr\y))/1.5)
End Function

; Decide de forma aleatoria en funcion del tipo de momia que sea
; si se hace o no algo
;
Function decide{spr.l}
  *Spr.TSprite=spr
  ret=False
  Select *Spr\stype
    Case #spt_Mummy_white
      ret = (Rnd(1000) < 200)
    Case #spt_Mummy_blue
      ret = (Rnd(1000) < 500)
    Case #spt_Mummy_yellow
      ret = (Rnd(1000) < 600)
    Case #spt_Mummy_orange
      ret = (Rnd(1000) < 700)
    Case #spt_Mummy_red
      ret = (Rnd(1000) < 900)
  End Select
  Function Return ret
End Function

; Matamos una momia
;
Statement killMummy{spr.l}
  *Spr.TSprite=spr
  *Spr\flip=0
  *Spr\state=#stMum_dying
  setMummyAnimation{*Spr}
End Statement

; Se llama cuando el personaje sale por la puerta
;
Statement killAllMummies{}
  SHARED lst_sprites()
  ResetList lst_sprites()
  While NextItem(lst_sprites())
    If lst_sprites()\stype<>#spt_Dagger
      killMummy{lst_sprites()}
    End If
  Wend
End Statement

Statement findTeleportPlace{spr.l}
  SHARED pyramid
  *Spr.TSprite=spr
  done=False
  While done=False
    cx = 2+Int(Rnd(pyramid\w-4))
    cy = 2+Int(Rnd(pyramid\h-4))
    done=gettileid{cx,cy,pyramid\work}=#It_none
    done=done AND gettileid{cx+1,cy,pyramid\work}=#It_none
    done=done AND gettileid{cx,cy-1,pyramid\work}=#It_none
    done=done AND gettileid{cx+1,cy-1,pyramid\work}=#It_none
  Wend
  ; Bajamos hasta tocar suelo
  While checkItemSolid{gettileid{cx,cy+1,pyramid\work}}=False
    cy+1
  Wend
  *Spr\x = cx*10
  *Spr\y = cy*10+9
End Statement

; Logica de las momias
;
Statement doMoveMummy{spr.l}
  SHARED SprExplorer
  *Spr.TSprite=spr
  DEFTYPE.TItem item
  USEPATH *Spr

  Select \state
    Case #stSpr_init
      initTimer{\timer,90}
      \state=#stMum_limbus
      \animation\enabled=False
      \flip=0
      Select \stype
        Case #spt_Mummy_white
          \vel_walk=1
          \vel_stairs=1
        Case #spt_Mummy_blue
          \vel_walk=1
          \vel_stairs=2
        Case #spt_Mummy_yellow
          \vel_walk=2
          \vel_stairs=2
        Case #spt_Mummy_orange
          \vel_walk=1
          \vel_stairs=3
        Case #spt_Mummy_red
          \vel_walk=2
          \vel_stairs=3
      End Select
    Case #stMum_limbus
      If isTimerOut{\timer}
        \state=#stMum_appearing
        \animation\enabled=True
        setMummyAnimation{spr}
        playsound{#Snd_mummyappear}
      End If
    Case #stMum_appearing
      If doAnimation{\animation}=False
        If canFall{\x,\y,#Mum_vel_fall}=True
          \state=#stSpr_falling
        Else
          \state=#stMum_waiting
        End If
        setMummyAnimation{spr}
        initTimer{\timer,(1+Int(Rnd(3)))*60}
      End If
    Case #stMum_waiting
      r=doAnimation{\animation}
      If isTimerOut{\timer}
        \state=#stSpr_walk
        \flip=Abs(SprExplorer\x < \x)
        setMummyAnimation{spr}
        initTimer{\timer,(2+Int(Rnd(4)))*60}
      End If
    Case #stSpr_walk
      If detectMummyItem{\x,\y,item}=True
        Select item\otype
          Case #It_stair_ur
            If \state<>#stSpr_onstairs AND SprExplorer\y < \y AND decide{spr}=True
              \state=#stSpr_onstairs
              \stairtype=#It_stair_ur
              \x = item\x*10+2
              \y = item\y*10+9
              \ystair = item\y
              \flip=0
              setMummyAnimation{spr}
            End If
          Case #It_stair_dl
            If \state<>#stSpr_onstairs AND SprExplorer\y > \y AND decide{spr}=True
              \state=#stSpr_onstairs
              \stairtype=#It_stair_dl
              \x = (item\x+1)*10-2
              \y = item\y*10+2
              \ystair = item\y
              \flip=1
              setMummyAnimation{spr}
            End If
          Case #It_stair_ul
            If \state<>#stSpr_onstairs AND SprExplorer\y < \y AND decide{spr}=True
              \state=#stSpr_onstairs
              \stairtype=#It_stair_ul
              \x = (item\x+1)*10-2
              \y = item\y*10+9
              \ystair = item\y
              \flip=1
              setMummyAnimation{spr}
            End If
          Case #It_stair_dr
            If \state<>#stSpr_onstairs AND SprExplorer\y > \y AND decide{spr}=True
              \state=#stSpr_onstairs
              \stairtype=#It_stair_dr
              \x = item\x*10+2
              \y = item\y*10+2
              \ystair = item\y
              \flip=0
              setMummyAnimation{spr}
            End If
        End Select
        If \state<>#stSpr_walk
          Pop Select
          Statement Return
        End If
      End If

      If \flip
        If canMoveLeft{\x,\y,\vel_walk}=True
          \x-\vel_walk
        Else
          ; si no puede moverse a la izquierda, pero
          ; puede saltar, lo hace si lo decide
          ;
          If decide{spr}=True
            If canJump{\x,\y,-1}=True
              initJump{spr,#stSpr_jump_left}
              setMummyAnimation{spr}
              Pop Select
              Statement Return
            End If
          End If

          If canMoveRight{\x,\y,\vel_walk}=True
            \flip=0
          Else
            ; no se puede mover a ningun lado, intenta saltar
            If canJump{\x,\y,-1}=True
              initJump{spr,#stSpr_jump_left}
            Else
              initJump{spr,#stSpr_jump_right}
            End If
            setMummyAnimation{spr}
            Pop Select
            Statement Return
          End If
        End If
      Else
        If canMoveRight{\x,\y,\vel_walk}=True
          \x+\vel_walk
        Else
          ; si no puede moverse a la derecha, pero
          ; puede saltar, lo hace si lo decide
          ;
          If decide{spr}=True
            If canJump{\x,\y,1}=True
              initJump{spr,#stSpr_jump_right}
              setMummyAnimation{spr}
              Pop Select
              Statement Return
            End If
          End If

          If canMoveLeft{\x,\y,\vel_walk}=True
            \flip=1
          Else
            ; no se puede mover a ningun lado, intenta saltar
            If canJump{\x,\y,1}=True
              initJump{spr,#stSpr_jump_right}
            Else
              initJump{spr,#stSpr_jump_left}
            End If
            setMummyAnimation{spr}
            Pop Select
            Statement Return
          End If
        End If
      End If
      r=doAnimation{\animation}
      If canFall{\x,\y,#Mum_vel_fall}=True
        ; En determinados casos, en lugar de caer, puede
        ; decidir saltar
        If SprExplorer\y <= \y AND decide{spr}=True
          If \flip
            initJump{spr,#stSpr_jump_left}
          Else
            initJump{spr,#stSpr_jump_right}
          End If
          setMummyAnimation{spr}
        Else
          \state=#stSpr_falling
          setMummyAnimation{spr}
        End If
      Else
        If isTimerOut{\timer}
          If Rnd(1000)<200
            \teleport=True
            killMummy{spr}
          Else
            \state=#stMum_waiting
            initTimer{\timer,(1+Int(Rnd(1)))*60}
            setMummyAnimation{spr}
          End If
        End If
      End If
    Case #stSpr_falling
      If canFall{\x,\y,#Mum_vel_fall}=True
        \y+#Mum_vel_fall
      Else
        centerCellY{spr}
        \state=#stSpr_walk
        setMummyAnimation{spr}
      End If
    Case #stSpr_jump_left
      \flip=1
      doJump{spr,#Mum_vel_jump,#Mum_vel_fall}
    Case #stSpr_jump_right
      \flip=0
      doJump{spr,#Mum_vel_jump,#Mum_vel_fall}
    Case #stSpr_onstairs
      r=detectMummyItem{\x,\y,item}
      doControlStair{spr,(\flip=1),(\flip=0),\vel_stairs}
    Case #stMum_dying
      If doAnimation{\animation}=False
        \animation\enabled=False
        \flip=0
        \state=#stMum_limbus
        If \teleport
          \teleport=False
          findTeleportPlace{spr}
          initTimer{\timer,30}
        Else
          initTimer{\timer,5*60}
        End If
      End If
  End Select
End Statement

; Carga los sonidos en funcion del SOUNDSET
;
Statement reloadSoundset{}
  SHARED CLASSIC_SOUNDSET
  QAMIGA
  new$=""
  If CLASSIC_SOUNDSET=False
    new$=".new"
  End If
  Free Sound #Snd_jump
  LoadSound #Snd_jump,"sound/jump.iff"+new$
  Free Sound #Snd_dead
  LoadSound #Snd_dead,"sound/dead.iff"+new$
  Free Sound #Snd_door
  LoadSound #Snd_door,"sound/door.iff"+new$
  Free Sound #Snd_rotadoor
  LoadSound #Snd_rotadoor,"sound/rotadoor.iff"+new$
  Free Sound #Snd_falling
  LoadSound #Snd_falling,"sound/fall.iff"+new$
  Free Sound #Snd_mummyappear
  LoadSound #Snd_mummyappear,"sound/mummyappear.iff"+new$
  Free Sound #Snd_mummydead
  LoadSound #Snd_mummydead,"sound/mummydead.iff"+new$
  VWait 100:BLITZ
End Statement

; ------------
; MAIN PROGRAM
; ------------
.MainProgram

WBStartup:NoCli:CloseEd
SetErr:End:End SetErr
CloseWorkBench_

; Activamos el temporizador
;
Gosub ActivateTimer

; Configuramos el temporizador para que cada 5 segundos brille una joya
;
initTimer{jbright\timer,60*5}

VWait 100:BLITZ
BlitzKeys On

Gosub SplashScreen
Gosub SplashKonami
Repeat
  Gosub SplashMenu
  If NOT EXIT_GAME Then Gosub StartGame
Until EXIT_GAME=True

; Liberamos recursos
Gosub ReleaseDisplay
Gosub FreePyramid
Gosub DisableTimer

AMIGA
OpenWorkBench_
End

; ------------------------
; Pantalla de presentacion
; ------------------------
.SplashScreen
QAMIGA
BitMap #BufferA,320,256,5
BitMap #BufferB,320,256,5
LoadBlitzFont 0,"taito.font"
Use BlitzFont 0
LoadBitMap #BufferB,"pics/portada.lbm",0
VWait 100:BLITZ
Slice 0,#TopSlice,320,256,$fff8,5,8,32,320,320
Use Palette 0
Use BitMap #BufferA
Show #BufferA,0,0

For y0=0 To 14
  For y1=0 To 240 Step 15
    Scroll 0,y0+y1,320,1,0,y0+y1,#BufferB
  Next
  VWait 4
Next

; Ya no necesitamos el bufferB, asi que lo eliminamos
Free BitMap #BufferB
BitMapOutput #BufferA
Colour 31,0
Locate 2,29:Print"LOADING DATA"
Gosub SetupGameResources
Return

; ---------------------------
; Carga Recursos del Juego
; ---------------------------
.SetupGameResources
QAMIGA
Buffer #BBuff0,4096
Buffer #BBuff1,4096
LoadShapes #BaseTiles,"pics/graphics.shp"
LoadPalette #GamePalette,"pics/graphics.pal"
LoadMedModule #Med_music,"sound/music.med"
LoadSound #Snd_picking,"sound/digger.iff"
LoadSound #Snd_takejewel,"sound/takejewel.iff"
LoadSound #Snd_takepicker,"sound/takepicker.iff"
LoadSound #Snd_throwdagger,"sound/throwknife.iff"
reloadSoundset{}
Return

; ---------------------------
; Mostramos Logo Konami
; ---------------------------
.SplashKonami
QAMIGA
LoadShape #BaseTopShapes,"pics/kasoftware.lbm",0
VWait 100:BLITZ
Gosub ReleaseDisplay
BitMap 0,320,240,2
Slice 0,#TopSlice,320,240,$fff8,2,8,4,320,320
Use Palette 0
Use BitMap 0
Cls 0
Show 0,0,0
DisplayOn
For y=0 To 160 Step 2
  VWait
  ClipBlit #BaseTopShapes,98,240-y
Next
Gosub WaitKeyOrButton
Cls 0
Free Shape #BaseTopShapes
Return

; ---------------------------
; Mostramos Menu Principal
; ---------------------------
.SplashMenu
Gosub ReleaseDisplay
QAMIGA
LoadShape #BaseTopShapes,"pics/kvlogo.lbm",0
VWait 100:BLITZ
BitMap 0,320,240,4
Slice 0,#TopSlice,320,240,$fff8,4,8,16,320,320
Use Palette 0
Use BitMap 0
BitMapOutput 0
Show 0,0,0
ClipBlit #BaseTopShapes,80,30
Free Shape #BaseTopShapes

;Define el Rainbow para el scroll y las letras del menu
DEFTYPE.TRainbow rain
USEPATH rain
\cindex=1
\y0=14*8 : \r0=0 : \g0=0 : \b0=0
\y1=16*8 : \r1=10 : \g1=10 : \b1=15
makeRainbow{rain}
For \y0=16*8 To 27*8 Step 2
  ColSplit 1,10,10,15,\y0
  ColSplit 1,8,8,12,\y0+1
Next
\y0=27*8 : \r0=10 : \g0=10 : \b0=15
\y1=29*8 : \r1=0 : \g1=0 : \b1=0
makeRainbow{rain}
\y0=29*8 : \r0=0 : \g0=0 : \b0=0
\y1=30*8 : \r1=0 : \g1=0 : \b1=0
makeRainbow{rain}

; Definimos Rainbow para color blanco
;
For \y0=12*8 To 19*8 Step 2
  ColSplit #Color_white,15,15,15,\y0
  ColSplit #Color_white,12,12,12,\y0+1
Next

Gosub SplashMenuRedraw
option.b=0
DisplayOn

startMusic{#Med_maintitle,0,15}
Repeat
  Colour #Color_red,#Color_black
  Repeat
    updateVKeysWithRelease{}
    VWait
    playMusic{}
    If VKeys\up AND option>0
      Locate 10,15+option : Print " "
      option-1
    Else
      If VKeys\down AND option<3
        Locate 10,15+option : Print " "
        option+1
      End If
    End If
    Locate 10,15+option : Print ">"
  Until VKeys\fire
  VWait 10

  Select option
    Case 0
      startMusic{#Med_intro,60*5,15}
      Pop Select
      Return
    Case 1
      stopMusic{}
      CLASSIC_SOUNDSET=NOT CLASSIC_SOUNDSET
      Colour #Color_white,#Color_black
      Locate 12,16:Print "LOADING SOUNDS..."
      reloadSoundset{}
      If CLASSIC_SOUNDSET
        Locate 12,16:Print "CLASSIC SOUNDSET "
      Else
        Locate 12,16:Print "MODERN SOUNDSET  "
      End If
      resumeMusic{}
    Case 2
      Gosub SplashCredits
    Case 3
      stopMusic{}
      EXIT_GAME=True
      Pop Select
      Return
  End Select
Forever

.SplashMenuRedraw
Boxf 0,12*8,320,240,0
Colour #Color_white,#Color_black
Locate 7,12:Print "KONAMI & M.A SOFTWARE 2021"

Locate 12,15:Print "START GAME"
If CLASSIC_SOUNDSET
  Locate 12,16:Print "CLASSIC SOUNDSET"
Else
  Locate 12,16:Print "MODERN SOUNDSET "
End If
Locate 12,17:Print "CREDITS"
Locate 12,18:Print "EXIT GAME"
Return

.SplashCredits
count.b=0
scrup.b=0
Boxf 0,12*8,320,240,0
Colour 1,#Color_black
stopMusic{}
Repeat
  VWait 2
  updateVKeysWithRelease{}
  If scrup=0
    Locate 20-Len(CREDITS(count))/2,29
    Print CREDITS(count)
    count=(count+1) MOD 20
  End If
  scrup=(scrup+1) MOD 8
  VWait
  Scroll 0,14*8+1,320,(30-14)*8-1,0,14*8
Until VKeys\fire
Gosub SplashMenuRedraw
startMusic{#Med_maintitle,0,15}
Return

; ---------------------------
; Configuramos Juego
; ---------------------------
.StartGame
LAST_LEVEL=0
LIVES=4
SCORE=0
pyramid\level=1
SprExplorer\state=#stSpr_init

.SetupLevel
Gosub ReleaseDisplay
BitMap #BufferA,640,220+#SafeMargin,4
BitMap #BufferB,640,220+#SafeMargin,4
BitMap #BufferC,320,20,4

VWait 100:BLITZ
Slice 0,#TopSlice,320,20,$fff0,4,8,16,320,320
Use Palette #GamePalette
For y=0 To 18 Step 2
  ColSplit #Color_white,15,15,15,y
  ColSplit #Color_white,12,12,12,y+1
Next
Show #BufferC,0,0
Slice 1,#TopSlice+20,320,220,$fff8,4,8,16,640,640

.StartLevel
Use BitMap #BufferA
VWait
Cls #Color_black
Use Palette #GamePalette
updateScore{0}
Show #BufferA,0,#SafeMargin
DisplayOn
; Si estamos muerto, seguimos en el mismo nivel
; y no lo cargamos
;
If SprExplorer\state<>#stEx_die
  Gosub ReadPyramid
  VWait 100:BLITZ
End If
setExplorer{LAST_LEVEL}
Gosub DrawPyramid
dbuffer.b = #BufferB
restartTimer{jbright\timer}

TRICK$=""
TRICK_INMUNITY=False

Repeat
  playMusic{}
  updateVKeys{}

  ; Pintamos los elementos en el buffer back
  Use BitMap dbuffer
  UnBuffer dbuffer

  ; Dibuja las operaciones pendientes
  Gosub DrawPending

  ; Dibuja brillo de joyas
  Gosub DrawJewelBright

  If *PInDoor<>0
    If *PInDoor\enabled Then controlDoor{*PInDoor}
  End If
  If *POutDoor<>0
    If *POutDoor\enabled Then controlDoor{*POutDoor}
  End If

  ; Cada 10 fotogramas, controlamos los muros
  If (FRAME_COUNTER MOD 5)=0 Then doControlWalls{}

  ; Controla el Explorador y los otros Sprites
  Gosub CtrlExplorer
  Gosub CtrlSprites

  ; Dibuja Sprites
  Gosub DrawSprites
  BBlit dbuffer,SprExplorer\animation\frame+#Exp_flipoff*SprExplorer\flip,SprExplorer\x,SprExplorer\y+#SafeMargin

  ;BitMapOutput dbuffer
  ;Locate 10,10: Print TRICK$," "
  ;Locate 20,11: Print "F: ",AvailMem_(4)," "

  VWait

  ; Ajustamos la camara del scroll
  ;
  If pyramid\w>32
    CameraX = QLimit(SprExplorer\x - 160,0,320)
  End If

  Show dbuffer,CameraX,#SafeMargin

  ; Si se pulsa ESC, mostramos menu
  ;
  If VKeys\esc
    stopMusic{}
    Select getMenuGameOption{dbuffer}
      Case 0 ; Continue
      Case 1 ; Restart Level
        killExplorer{}
      Case 2 ; Exit Game
        SprExplorer\state=#stEx_die
        VKeys\esc=True
    End Select

    ; Volvemos a poner la musica, si no estamos muriendo
    ;
    If SprExplorer\state<>#stEx_dying
      resumeMusic{}
    End If
  End If

  dbuffer = 1 - dbuffer

  ; Gestiona los trucos
  ;
  a$=Inkey$
  If (a$<>"")
    If a$<>Chr$(13)
      TRICK$=TRICK$+UCase$(a$)
    Else
      a$=Inkey$
      If TRICK$="SHOWMETHEDOORS"
        showDoorsForExit{}
      Else
        If TRICK$="GETMEMORELIVES"
          LIVES=99
          updateScore{0}
        Else
          If Left$(TRICK$,12)="GETMETOLEVEL"
            lev=Val(Right$(TRICK$,2))
            If lev<1 Then lev=1
            If lev>16 Then lev=16
            pyramid\level=lev
            LAST_LEVEL=lev-1
            *PEnterDoor=0
            SprExplorer\state=#stEx_leveldone
          Else
            If TRICK$="GETMEINMUNITY"
              TRICK_INMUNITY=True
            End If
          End If
        End If
      End If
      TRICK$=""
    End If
  EndIf

Until SprExplorer\state=#stEx_leveldone OR SprExplorer\state=#stEx_die

stopMusic{}

; Limpiamos los buffers de fondos de sprites
FlushBuffer #BufferA
FlushBuffer #BufferB

If VKeys\esc
  FadeOut #GamePalette,0,1,15
  Return
End If

If SprExplorer\state=#stEx_leveldone
  FadeOut #GamePalette,0,1,15
  updateScore{2000}
  If *PEnterDoor<>0
    LAST_LEVEL = pyramid\level
    Select *PEnterDoor\doortype
      Case #doort_in
        pyramid\level-1
      Case #doort_out
        pyramid\level+1
      Case #doort_inout
        pyramid\level+1
    End Select
  End If
  Gosub PyramidMap
  If pyramid\level=16
    Gosub EndGame
    Return
  End If
  Goto SetupLevel
Else
  LIVES-1
  If LIVES<0
    gameOver{1-dbuffer}
    FadeOut #GamePalette,0,1,15
    Return
  End If
  FadeOut #GamePalette,0,1,15
  Goto StartLevel
End If

; -------------------------------
; Dibuja el mapa de las piramides
; -------------------------------
.PyramidMap
Gosub ReleaseDisplay
BitMap #BufferA,320,240,4
Use BitMap #BufferA
QAMIGA
LoadBitMap #BufferA,"pics/pergamino.lbm",0
GetaShape #BaseTopShapes,0,0,20,16
GetaShape #BaseTopShapes+1,20,0,20,16
GetaShape #BaseTopShapes+2,40,0,20,16
GetaShape #BaseTopShapes+3,97,161,20,16
VWait 100:BLITZ
Boxf 0,0,60,16,0

Slice 0,#TopSlice,320,240,$fff0,4,8,16,320,320
For a=0 To 15:PalRGB 1,a,0,0,0:Next
Use Palette 1
Show #BufferA,0,0

BitMapOutput #BufferA
Colour 15,0
Locate 14,2:Print "PYRAMID"+Chr$(39)+"S MAP"

DisplayOn
FadeIn 0,0,1,15
coords.l = ?coord_maps

lev_from=LAST_LEVEL-1
If lev_from<0 Then lev_from=0
lev_to=pyramid\level-1

; Obtenemos las coordenadas graficas
; de las piramides
;
pax.w=Peek.w(coords+lev_from*4)
pay.w=Peek.w(coords+lev_from*4+2)
pbx.w=Peek.w(coords+lev_to*4)
pby.w=Peek.w(coords+lev_to*4+2)

startMusic{#Med_pyramidmap,0,15}

; Colocamos la piramide donde estamos
;
For a=0 To 5
  Blit #BaseTopShapes,pax,pay
  For b=1 To 10:playMusic{}:VWait:Next
  Blit #BaseTopShapes+1,pax,pay
  For b=1 To 10:playMusic{}:VWait:Next
Next

; Colocamos la piramide donde vamos
;
If pyramid\level<16
  base.w=#BaseTopShapes
Else
  base.w=#BaseTopShapes+2
End If

For a=0 To 5
  Blit base+1,pbx,pby
  For b=1 To 10:playMusic{}:VWait:Next
  Blit base,pbx,pby
  For b=1 To 10:playMusic{}:VWait:Next
Next

For b=1 To 120:playMusic{}:VWait:Next
stopMusic{}

Free Shape #BaseTopShapes
Free Shape #BaseTopShapes+1
Free Shape #BaseTopShapes+2
Free Shape #BaseTopShapes+3
FadeOut 0,0,1,15
Gosub ReleaseDisplay
Return

; -------------------------
; Dibuja el final del juego
; -------------------------
.EndGame
Gosub ReleaseDisplay
BitMap #BufferA,320,200,4
Use BitMap #BufferA
QAMIGA
LoadBitMap #BufferA,"pics/ending.lbm",0
VWait 100:BLITZ
BitMapOutput #BufferA
Scroll 0,0,320,138,0,40
Boxf 0,0,320,39,0
Slice 0,#TopSlice,320,200,$fff0,4,8,16,320,320
For a=0 To 15:PalRGB 1,a,0,0,0:Next
Use Palette 1
PalRGB 0,9,0,0,0

;Define el Rainbow para el cielo
DEFTYPE.TRainbow rain
USEPATH rain
\cindex=9
\y0=30+40 : \r0=0 : \g0=0 : \b0=0
\y1=30+52 : \r1=0 : \g1=0 : \b1=8
makeRainbow{rain}
\y0=30+52 : \r0=0 : \g0=0 : \b0=8
\y1=30+61 : \r1=7 : \g1=0 : \b1=9
makeRainbow{rain}
\y0=30+61 : \r0=7 : \g0=0 : \b0=9
\y1=30+64 : \r1=7 : \g1=0 : \b1=9
makeRainbow{rain}
Show #BufferA,0,0
DisplayOn
FadeIn 0,0,1,15
SprExplorer\x=5
SprExplorer\y=40+50
SprExplorer\state=#stSpr_walk
setExplorerAnimation{}

FlushBuffer #BufferA
startMusic{#Med_endgame,0,15}
DEFTYPE.TTimer tmr
initTimer{tmr,26*60}
Repeat
  VWait
  playMusic{}
  UnBuffer #BufferA
  BBlit #BufferA,SprExplorer\animation\frame,SprExplorer\x,SprExplorer\y
  SprExplorer\x+1
  If SprExplorer\y<140 Then SprExplorer\y+1
  r=doAnimation{SprExplorer\animation}
Until SprExplorer\x>=220
FlushBuffer #BufferA

Colour 15,9
Locate 22,4: Print "CONGRATULATIONS"
Locate 22,6: Print "YOU HAVE DEFEATED"
Locate 22,8: Print "THE MUMMIES"
While isTimerOut{tmr}=False
  playMusic{}
  VWait
Wend
stopMusic{}
FadeOut 0,0,1,15
Return

; -----------------------------
; Dibuja operaciones pendientes
; -----------------------------
.DrawPending
  ResetList lst_opdraw()
  While NextItem(lst_opdraw())
    USEPATH lst_opdraw()
    puttileid{\x,\y,pyramid\work,\work}
    tback.w=gettileid{\x,\y,pyramid\back}&$ff
    If tback>0
      Boxf \x*10,\y*10+#SafeMargin,\x*10+9,\y*10+9+#SafeMargin,#Color_black
      Blit #BaseTiles+tback-1,\x*10,\y*10+#SafeMargin
    End If
    If \p0&$ff > 0 Then Blit #BaseTiles+\p0&$ff-1,\x*10,\y*10+#SafeMargin
    If \p1&$ff>0 Then Blit #BaseTiles+\p1&$ff-1,\x*10,\y*10+#SafeMargin
    \buffc-1
    If \buffc=0 Then KillItem lst_opdraw()
  Wend
Return

; -------------------------
; Dibuja el brillo de joyas
; -------------------------
.DrawJewelBright
If isTimerOut{jbright\timer}
  ; Buscamos una joya para que brille
  getBrightJewel{jbright}
  restartTimer{jbright\timer}
Else
  If jbright\pjewel<>0
    *Pjw.TItem=jbright\pjewel
    cidx.b=(*Pjw\p1 / 3)
    If *Pjw\enabled AND *Pjw\p1<27
      If cidx=7
        cidx-2
      Else
        If cidx=8 Then cidx=0
      End If
      Blit #BaseTiles+(*Pjw\p0&$ff)+cidx-1,*Pjw\x*10,*Pjw\y*10+#SafeMargin
    Else
      jbright\pjewel=0
    End If
    *Pjw\p1+1
  End If
End If
Return

; ------------------------
; Dibuja los otros sprites
; ------------------------
.DrawSprites
  ResetList lst_sprites()
  While NextItem(lst_sprites())
    USEPATH lst_sprites()
    If \animation\enabled
      BBlit dbuffer,\animation\frame+(\flipoffset*\flip),\x,\y+#SafeMargin
    End If
  Wend
Return

; --------------------
; Controla los Sprites
; --------------------
.CtrlSprites
  ResetList lst_sprites()
  USEPATH lst_sprites()
  order.b=0
  While NextItem(lst_sprites())
    If \stype=#spt_Dagger
      doMoveDagger{lst_sprites()}
      ; Chequeamos colision de la daga con las posibles momias
      PushItem lst_sprites()
      *dagger.TSprite=lst_sprites()
      ResetList lst_sprites()
      While NextItem(lst_sprites())
        If \stype<>#spt_Dagger AND \state>#stSpr_init AND \state<#stMum_limbus AND \state<>#stSpr_onstairs
          If RectsHit(\x-7,\y-19,16,20,*dagger\x-6,*dagger\y-6,12,12)
            stopDagger{*dagger}
            playsound{#Snd_mummydead}
            killMummy{lst_sprites()}
            updateScore{100}
          End If
        End If
      Wend
      PopItem lst_sprites()
    Else
      If order=(FRAME_COUNTER MOD 2)
        doMoveMummy{lst_sprites()}
        ; Chequeamos la colision de la momia con el explorador
        If SprExplorer\state>#stSpr_init AND SprExplorer\state<#stEx_dying
          If \state>#stSpr_init AND \state<#stMum_limbus
            ; Si los dos estan en la escalera, o los dos
            ; estan fuera de la escalera, colisionan
            ;
            testc = (SprExplorer\state=#stSpr_onstairs AND \state=#stSpr_onstairs)
            testc = testc OR (SprExplorer\state<>#stSpr_onstairs AND \state<>#stSpr_onstairs)
            If testc AND TRICK_INMUNITY=False
              If RectsHit(SprExplorer\x-6,SprExplorer\y-15,12,10,\x-6,\y-15,12,10)
                killExplorer{}
              End If
            End If
          End If
        End If
      End If
      order=(order+1) MOD 2
    End If
    If NOT lst_sprites()\enabled
      KillItem lst_sprites()
    End If
  Wend
Return

; ----------------------
; Controla al explorador
; ----------------------
.CtrlExplorer

If SprExplorer\state=#stEx_goingout
  r=doAnimation{SprExplorer\animation}
  If SprExplorer\counter1<40
    If SprExplorer\counter1=0
      killAllMummies{}
    End If
    SprExplorer\counter1+1
    If (SprExplorer\counter1 MOD 10)=0
      SprExplorer\x+1
      SprExplorer\y-1
    End If
  Else
    SprExplorer\state=#stEx_leveldone
  End If
  Return
End If

If giradoor\enabled
  drawGiratory{}
  Return
End If

; Si esta muriendo, esperamos a la muerte y retornamos
;
If SprExplorer\state=#stEx_dying
  If doAnimation{SprExplorer\animation}=False
    SprExplorer\state=#stEx_die
    SprExplorer\animation\frame=SprExplorer\animation\framebase+3
  End If
  Return
End If

; Si esta muerto, no se hace nada mas
;
If SprExplorer\state=#stEx_die Then Return

; Caso que este en una escalera
;
If SprExplorer\state=#stSpr_onstairs
  doControlStair{SprExplorer,VKeys\left,VKeys\right,#Exp_vel_walk}
  Return
End If

; Detectamos si se ha colisionado con un pico, daga o joya
; o si estamos en un escalon de subida
;
If detectExplorerItem{SprExplorer\x,SprExplorer\y,scritem}=True
  scritem\work=0
  Select scritem\otype
    Case #It_jewel
      playsound{#Snd_takejewel}
      addopdraw{scritem}
      disableJewel{scritem}
      pyramid\jewels-1
      updateScore{500}

      ; Si se han cogido todas las joyas, mostramos las puertas
      ; de salida
      ;
      If pyramid\jewels=0
        showDoorsForExit{}
      End If

    Case #It_picker
      If SprExplorer\object=#It_none
        playsound{#Snd_takepicker}
        addopdraw{scritem}
        SprExplorer\object=#It_picker
        setExplorerAnimation{}
      End If
    Case #It_dagger
      If SprExplorer\object=#It_none
        playsound{#Snd_takepicker}
        scritem\p0=gettileid{scritem\x,scritem\y,pyramid\front}
        addopdraw{scritem}
        SprExplorer\object=#It_dagger
        setExplorerAnimation{}
      End If
    Case #It_stair_ur
      If SprExplorer\state<>#stSpr_onstairs AND VKeys\up AND VKeys\right
        SprExplorer\state=#stSpr_onstairs
        SprExplorer\stairtype=#It_stair_ur
        SprExplorer\x = scritem\x*10
        SprExplorer\y = scritem\y*10+9
        SprExplorer\ystair = scritem\y
        setExplorerAnimation{}
      End If
    Case #It_stair_dl
      If SprExplorer\state<>#stSpr_onstairs AND VKeys\down AND VKeys\left
        SprExplorer\state=#stSpr_onstairs
        SprExplorer\stairtype=#It_stair_dl
        SprExplorer\x = scritem\x*10+9
        SprExplorer\y = scritem\y*10-1
        SprExplorer\ystair = scritem\y
        setExplorerAnimation{}
      End If
    Case #It_stair_ul
      If SprExplorer\state<>#stSpr_onstairs AND VKeys\up AND VKeys\left
        SprExplorer\state=#stSpr_onstairs
        SprExplorer\stairtype=#It_stair_ul
        SprExplorer\x = scritem\x*10+9
        SprExplorer\y = scritem\y*10+9
        SprExplorer\ystair = scritem\y
        setExplorerAnimation{}
      End If
    Case #It_stair_dr
      If SprExplorer\state<>#stSpr_onstairs AND VKeys\down AND VKeys\right
        SprExplorer\state=#stSpr_onstairs
        SprExplorer\stairtype=#It_stair_dr
        SprExplorer\x = scritem\x*10
        SprExplorer\y = scritem\y*10-1
        SprExplorer\ystair = scritem\y
        setExplorerAnimation{}
      End If
    Case #It_rgiratory
      startGiratoryDoor{scritem}
      playsound{#Snd_rotadoor}
      Pop Select                  ; Importante, sino se cuelga.
      Return
    Case #It_lgiratory
      startGiratoryDoor{scritem}
      playsound{#Snd_rotadoor}
      Pop Select                  ; Importante, sino se cuelga.
      Return
    Case #It_push_in
      If *PInDoor\state=#stDoor_waitingopen
        *PInDoor\state=#stDoor_opening
      End If
    Case #It_push_out
      If *POutDoor\state=#stDoor_waitingopen
        *POutDoor\state=#stDoor_opening
      End If
  End Select
Else
  scritem\otype=0
End If

; Caso que estemos saltando
If SprExplorer\state >= #stSpr_jump_left AND SprExplorer\state <= #stSpr_jump_right
  doJump{SprExplorer,#Exp_vel_walk,#Exp_vel_fall}
  If SprExplorer\state <#stSpr_jump_left
    setExplorerAnimation{}
  End If
  Return
End If

; Si esta lanzando la daga
;
If SprExplorer\state=#stEx_throwdagger
  If SprExplorer\counter1>0
     SprExplorer\counter1-1
  Else
     SprExplorer\object=#It_none
     SprExplorer\state=#stSpr_walk
     setExplorerAnimation{}
  End If
  Return
End If

; Si esta picando
;
If SprExplorer\state=#stEx_picking
  If SprExplorer\counter1>0
    r=doAnimation{SprExplorer\animation}
    If (SprExplorer\counter1 MOD 10) = 0
      playsound{#Snd_picking}
      scritem\otype=#It_none
      scritem\x = pickinfo\x
      scritem\y = pickinfo\y+SprExplorer\counter3
      scritem\work=0
      If SprExplorer\counter2>2
        scritem\p0=0
        scritem\p1=0
      Else
        scritem\p0=gettileid{scritem\x,scritem\y,pyramid\front}
        scritem\p1=#Tile_break+SprExplorer\counter2
      End If
      SprExplorer\counter2+1
      addopdraw{scritem}
    End If
    SprExplorer\counter1-1
    If SprExplorer\counter1=40
      SprExplorer\counter2=0
      SprExplorer\counter3+1
    End If
  Else
    SprExplorer\object=#It_none
    SprExplorer\state=#stSpr_walk
    setExplorerAnimation{}
  End If
  Return
End If

; Si no hay nada debajo cuando caminamos, caemos
;
If canFall{SprExplorer\x,SprExplorer\y,#Exp_vel_fall}=True
  If (SprExplorer\state<>#stSpr_falling)
    SprExplorer\state=#stSpr_falling
    playsound{#Snd_falling}
  End If
  SprExplorer\y+#Exp_vel_fall
  Return
Else
  ; Sino, ajustamos la posicion correcta al suelo
  If (SprExplorer\state=#stSpr_falling)
    SprExplorer\state=#stSpr_walk
    setExplorerAnimation{}
  End If
  centerCellY{SprExplorer}
End If

; Detectamos salto, daga o pico
;
If VKeys\fire

  If SprExplorer\object=#It_none
    If SprExplorer\state=#stSpr_walk
      If canFall{SprExplorer\x,SprExplorer\y,#Exp_vel_fall}=False AND canJump{SprExplorer\x,SprExplorer\y,0}=True
        If VKeys\left
          SprExplorer\flip=1
          initJump{SprExplorer,#stSpr_jump_left}
        Else
          If VKeys\right
            SprExplorer\flip=0
            initJump{SprExplorer,#stSpr_jump_right}
          Else
            initJump{SprExplorer,#stSpr_jump_top}
          End If
        End If
        setExplorerAnimation{}
        playsound{#Snd_jump}
      End If
    End If
    Return
  End If

  ; Si lleva la daga, la lanza
  ;
  If SprExplorer\object=#It_dagger
    SprExplorer\counter1=10
    SprExplorer\state=#stEx_throwdagger
    playsound{#Snd_throwdagger}
    setExplorerAnimation{}
    throwdagger{SprExplorer\x,SprExplorer\y-10,SprExplorer\flip}
    Return
  End If

  ; Si lleva el pico, se pone a picar
  ;
  If SprExplorer\object=#It_picker
    whereCanPick{}
    If pickinfo\otype=#It_picker
      SprExplorer\counter1=40*pickinfo\p0
      SprExplorer\counter2=0
      SprExplorer\counter3=0
      SprExplorer\state=#stEx_picking
      setExplorerAnimation{}
      Return
    End If
  End If

End If

; Camina derecha o izquierda
;
If VKeys\left
  SprExplorer\flip=1
  r=doAnimation{SprExplorer\animation}
  If canMoveLeft{SprExplorer\x,SprExplorer\y,#Exp_vel_walk}
    SprExplorer\x-#Exp_vel_walk
  Else
    centerCellX{SprExplorer}
  End If
Else
  If VKeys\right
    SprExplorer\flip=0
    r=doAnimation{SprExplorer\animation}
    If canMoveRight{SprExplorer\x,SprExplorer\y,#Exp_vel_walk}
      SprExplorer\x+#Exp_vel_walk
    Else
      centerCellX{SprExplorer}
    End If
  Else
    restartAnimation{SprExplorer\animation}
  End If
End If
Return

; ---------------------------------
; Espera pulsacion de tecla o boton
; ---------------------------------
.WaitKeyOrButton
  exit.b=0
  Repeat
    If Joyb(0)<>0 OR Joyb(1)<>0 Then exit=1
    If RawStatus($40)<0 OR RawStatus($44)<0 OR RawStatus($45)<0 Then exit=1
  Until exit>0
  VWait 20
Return

; ------------------------------------
; Destruye Slices y Desconecta Display
; ------------------------------------
.ReleaseDisplay
  DisplayOff
  FreeSlices
  Free BitMap #BufferA
  Free BitMap #BufferB
  Free BitMap #BufferC
  Free BitMap #BufferDoor1
  Free BitMap #BufferDoor2
Return

; ------------------
; Dibuja la piramide
; ------------------
;
.DrawPyramid
BLITZ
Use BitMap #BufferA
Cls #Color_black
If pyramid\w>32
  CameraX = QLimit(SprExplorer\x - 160,0,320)
Else
  CameraX = 0
End If
Show #BufferA,CameraX,#SafeMargin

Use BitMap #BufferB
Cls #Color_black
For y=0 To pyramid\h-1
  For x=0 To pyramid\w-1
    lback.l = pyramid\back
    lfront.l = pyramid\front
    offset.w=pyramid\w*y+x
    lback+offset
    lfront+offset

    id=Peek.b(lback)&$ff
    If (id>0)
      Blit #BaseTiles + id - 1,x*10,y*10+#SafeMargin
    End If

    id=Peek.b(lfront)&$ff
    If (id>0)
      Blit #BaseTiles+id-1,x*10,y*10+#SafeMargin

      ; Sobre la capa de trabajo, anotamos los ladrillos
      ; ignorando el resto de elementos. Lo usaremos como
      ; mascara para saber si hay o no algo en una posicion
      ;
      ; L: Ladrillo
      If (id>0 AND id<20) OR (id>206 AND id<219)
        puttileid{x,y,pyramid\work,#It_brick}
      End If
    Else
      puttileid{x,y,pyramid\work,#It_none}
    End If
  Next
Next

; Procesamos los items del nivel
;
giradoor\enabled=False
pyramid\jewels=0
ClearList lst_opdraw()
ClearList lst_sprites()

ResetList lst_jewels()
While NextItem(lst_jewels())
  USEPATH lst_jewels()
  Blit #BaseTiles+\p0&$ff - 1,\x*10,\y*10+#SafeMargin
  puttileid{\x,\y,pyramid\work,\otype}
  \enabled=True
  pyramid\jewels+1
Wend

ResetList lst_walls()
While NextItem(lst_walls())
  USEPATH lst_walls()
  \enabled=True
  \counter1=0
  \tileid=gettileid{\x,\y,pyramid\front}
  \state=#stWall_waiting
Wend

ResetList lst_items()
While NextItem(lst_items())
  USEPATH lst_items()
  ; Momias
  If \otype=#It_mummy
    AddItem lst_sprites()
    lst_sprites()\state=#stSpr_init
    lst_sprites()\enabled=True
    lst_sprites()\animation\enabled=False
    lst_sprites()\flipoffset=#Mum_flipoff
    lst_sprites()\flip=0
    lst_sprites()\x=\x*10
    lst_sprites()\y=\y*10+9
    lst_sprites()\stype=\p0
  End If

  ; Picos, Dagas y Joyas
  If \otype=#It_picker OR \otype=#It_dagger
    Blit #BaseTiles+\p0&$ff - 1,\x*10,\y*10+#SafeMargin
    puttileid{\x,\y,pyramid\work,\otype}
  End If

  ; Escaleras
  If \otype=#It_stairs
    puttileid{\x,\y,pyramid\work,\p0}
    Select \p0
      Case #It_stair_dl
        puttileid{\x+1,\y,pyramid\work,#It_stairs}
      Case #It_stair_dr
        puttileid{\x-1,\y,pyramid\work,#It_stairs}
    End Select
  End If

  ; Puertas giratorias
  If \otype=#It_giratory
    For y=\y To \y+\p0-1
      If \p1=0
        puttileid{\x,y,pyramid\work,#It_rgiratory}
        puttileid{\x+1,y,pyramid\work,#It_brick}
        Blit #BaseTiles+#Tile_giratory_toright - 1,\x*10,y*10+#SafeMargin
        Blit #BaseTiles+#Tile_giratory_toright,(\x+1)*10,y*10+#SafeMargin
      Else
        puttileid{\x,y,pyramid\work,#It_brick}
        puttileid{\x+1,y,pyramid\work,#It_lgiratory}
        Blit #BaseTiles+#Tile_giratory_toleft - 1,\x*10,y*10+#SafeMargin
        Blit #BaseTiles+#Tile_giratory_toleft,(\x+1)*10,y*10+#SafeMargin
      End If
    Next
  End If
Wend

; Guardamos el background de las puertas
USEPATH *PInDoor
Free BitMap \backbuff
BitMap \backbuff,50,30,4
Use BitMap \backbuff
Scroll (\x-1)*10,\y*10+#SafeMargin,50,30,0,0,#BufferB

If *POutDoor<>0 AND *POutDoor<>*PInDoor
  USEPATH *POutDoor
  Free BitMap \backbuff
  BitMap \backbuff,50,30,4
  Use BitMap \backbuff
  Scroll (\x-1)*10,\y*10+#SafeMargin,50,30,0,0,#BufferB
End If

Use BitMap #BufferB

; Pintamos la puerta por la que ha entrado el personaje
;
drawDoor{*PEnterDoor,10,0,0}

; Hacemos que aparezca la pantalla con lineas verticales
;
Use BitMap #BufferA
For y0=0 To 9
  VWait 3
  For y1=20 To 230 Step 10
    Scroll 0,y0+y1,640,1,0,y0+y1,#BufferB
  Next
Next
Return

; ------------------------------------
; Carga la informacion de una piramide
; ------------------------------------
;
.ReadPyramid
QAMIGA
Gosub FreePyramid
name$=Str$(pyramid\level)
name$="data/level."+String$("0",2-Len(name$))+name$
ret=ReadFile(0,name$)
ReadMem 0,&pyramid\w,1
ReadMem 0,&pyramid\h,1
size.w=pyramid\w * pyramid\h
pyramid\front = AllocMem(size,65536+1)
pyramid\back  = AllocMem(size,65536+1)
pyramid\work  = AllocMem(size,65536+1)
ReadMem 0,pyramid\back,size
ReadMem 0,pyramid\front,size
items.b=0
item.b=0
ReadMem 0,&items,1
While items>0
  ReadMem 0,&item,1
  items-1
  someitems.b = item=#It_picker OR item=#It_dagger
  someitems = someitems OR item=#It_mummy OR item=#It_stairs
  someitems = someitems OR item=#It_giratory
  If someitems
    ret=AddItem(lst_items())
    lst_items()\otype=item
    ReadMem 0,&lst_items()\x,1
    ReadMem 0,&lst_items()\y,1
    ReadMem 0,&lst_items()\p0,1
    If item=#It_giratory
      ReadMem 0,&lst_items()\p1,1
    End If
    If item=#It_stairs Then lst_items()\p0+#It_stair_ur
    If item=#It_mummy Then lst_items()\p0+#spt_Mummy_white
  Else
    If item=#It_door
      ret=AddItem(lst_doors())
      ReadMem 0,&lst_doors()\x,1
      ReadMem 0,&lst_doors()\y,1
      ReadMem 0,&lst_doors()\doortype,1
      lst_doors()\otype=#It_door
    Else
      If item=#It_jewel
        ret=AddItem(lst_jewels())
        lst_jewels()\otype=item
        ReadMem 0,&lst_jewels()\x,1
        ReadMem 0,&lst_jewels()\y,1
        ReadMem 0,&lst_jewels()\p0,1
      Else
        If item=#It_wall
          ret=AddItem(lst_walls())
          ReadMem 0,&lst_walls()\x,1
          ReadMem 0,&lst_walls()\y,1
          ReadMem 0,&lst_walls()\y1,1
          ReadMem 0,&lst_walls()\x1,1
          initTimer{lst_walls()\timer,40}
        End If
      End If
    End If
  End If
Wend
CloseFile 0
Return

; ------------------------------------
; Libera la informacion de la piramide
; ------------------------------------
;
.FreePyramid
If (pyramid\w<>0)
  size.w=pyramid\w * pyramid\h
  FreeMem pyramid\front,size
  FreeMem pyramid\back,size
  FreeMem pyramid\work,size
  pyramid\w=0
  pyramid\h=0
  pyramid\back=0
  pyramid\front=0
  pyramid\work=0
  ClearList lst_sprites()
  ClearList lst_items()
  ClearList lst_jewels()
  ClearList lst_doors()
  ClearList lst_walls()
  ClearList lst_opdraw()
End If
Return

; ----------------------
; Activa el temporizador
; ----------------------
.ActivateTimer
SetInt 5
  TIMER_COUNTER+1
  If TIMER_COUNTER<0 Then TIMER_COUNTER=0
  FRAME_COUNTER=(FRAME_COUNTER+1) MOD 60
End SetInt
Return

; -------------------------
; Desactiva el temporizador
; -------------------------
.DisableTimer
ClrInt 5
Return

; ---------------------------
; Coordenadas Mapas Piramides
; ---------------------------
.coord_maps
Dc.w 81,63,   121,63,  161,63,  201,63
Dc.w 221,93,  181,93,  141,93,  101,93
Dc.w 81,123,  121,123, 161,123, 201,123
Dc.w 221,153, 181,153, 141,153, 97,161

; -------------------
; Animaciones Sprites
; -------------------
.anim_walk
Dc.b 2,4, 3,4, 4,4, 3,4 ,2,4 ,1,4 ,0,4 ,1,4 ,$ff

.anim_throwdagger
Dc.b 6,3, $ff

.anim_jump
Dc.b 5,20, $ff

.anim_dagger
Dc.b 0,2, 1,2, 2,2, 3,2, 4,2, 5,2, 6,2, 7,2, $ff

.anim_picking
Dc.b 0,5, 1,5, $ff

.anim_die
Dc.b 0,8, 1,8, 0,8, 1,8, 0,8, 1,8, 2,5, 3,5, 2,5, 3,5, 2,5, 3,5, $ff

.mummy_walk
Dc.b 0,2, 1,2, 2,2, 3,2, 4,2, 5,2, 6,2, 7,2, $ff

.mummy_jump
Dc.b 8,20, $ff

.mummy_wait
Dc.b 9,10, 10,10, $ff

.mummy_appear
Dc.b 0,3, 1,3, 2,3, 3,3, 4,3, 3,3, 2,3, 1,3, 0,3
Dc.b 1,3, 2,3, 3,3, 4,3, 5,3, 6,3, 7,3, 8,2, 9,2, $ff

.mummy_die
Dc.b 10,3, 11,3, 12,3, 13,3, 14,3, $ff

Return

